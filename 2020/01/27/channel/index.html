<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>channel通道 | 星脉</title><meta name="description" content="channel通道"><meta name="keywords" content="服务器,Golang"><meta name="author" content="wangguangatap"><meta name="copyright" content="wangguangatap"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="channel通道"><meta name="twitter:description" content="channel通道"><meta name="twitter:image" content="https://wangguangatap.github.io/img/golang/golang.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="channel通道"><meta property="og:url" content="https://wangguangatap.github.io/2020/01/27/channel/"><meta property="og:site_name" content="星脉"><meta property="og:description" content="channel通道"><meta property="og:image" content="https://wangguangatap.github.io/img/golang/golang.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://wangguangatap.github.io/2020/01/27/channel/"><link rel="prev" title="Go语言并发Goroutine" href="https://wangguangatap.github.io/2020/01/27/goroutine/"><link rel="next" title="Go语言反射" href="https://wangguangatap.github.io/2020/01/27/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">星脉</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#channel-通道"><span class="toc_mobile_items-text">channel 通道</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、-什么是通道"><span class="toc_mobile_items-text">一、 什么是通道</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1-通道的概念"><span class="toc_mobile_items-text">1.1 通道的概念</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2-通道的声明"><span class="toc_mobile_items-text">1.2 通道的声明</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3-channel-的数据类型"><span class="toc_mobile_items-text">1.3 channel 的数据类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4-通道的注意点"><span class="toc_mobile_items-text">1.4 通道的注意点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、通道的使用语法"><span class="toc_mobile_items-text">二、通道的使用语法</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1-发送和接收"><span class="toc_mobile_items-text">2.1 发送和接收</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2-发送和接收默认是阻塞的"><span class="toc_mobile_items-text">2.2 发送和接收默认是阻塞的</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3-死锁"><span class="toc_mobile_items-text">2.3 死锁</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三、-关闭通道"><span class="toc_mobile_items-text">三、 关闭通道</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#四、通道上的范围循环"><span class="toc_mobile_items-text">四、通道上的范围循环</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#五、非缓冲通道"><span class="toc_mobile_items-text">五、非缓冲通道</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#六、缓冲通道"><span class="toc_mobile_items-text">六、缓冲通道</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#七、双向通道"><span class="toc_mobile_items-text">七、双向通道</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#八、单向通道"><span class="toc_mobile_items-text">八、单向通道</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#九、time-包中的通道相关函数"><span class="toc_mobile_items-text">九、time 包中的通道相关函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#9-1、time-NewTimer"><span class="toc_mobile_items-text">9.1、time.NewTimer()</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#9-2、timer-Stop"><span class="toc_mobile_items-text">9.2、timer.Stop</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#9-3、time-After"><span class="toc_mobile_items-text">9.3、time.After()</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#十、select-语句"><span class="toc_mobile_items-text">十、select 语句</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#十一、Go-语言的-CSP-模型"><span class="toc_mobile_items-text">十一、Go 语言的 CSP 模型</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-1、CSP-是什么"><span class="toc_mobile_items-text">11.1、CSP 是什么</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-2、Golang-CSP"><span class="toc_mobile_items-text">11.2、Golang CSP</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-3、Channel"><span class="toc_mobile_items-text">11.3、Channel</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-4、Goroutine"><span class="toc_mobile_items-text">11.4、Goroutine</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-5、Goroutine-调度器"><span class="toc_mobile_items-text">11.5、Goroutine 调度器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#11-6、最后"><span class="toc_mobile_items-text">11.6、最后</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#channel-通道"><span class="toc-text">channel 通道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、-什么是通道"><span class="toc-text">一、 什么是通道</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-通道的概念"><span class="toc-text">1.1 通道的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-通道的声明"><span class="toc-text">1.2 通道的声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-channel-的数据类型"><span class="toc-text">1.3 channel 的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-通道的注意点"><span class="toc-text">1.4 通道的注意点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、通道的使用语法"><span class="toc-text">二、通道的使用语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-发送和接收"><span class="toc-text">2.1 发送和接收</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-发送和接收默认是阻塞的"><span class="toc-text">2.2 发送和接收默认是阻塞的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-死锁"><span class="toc-text">2.3 死锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、-关闭通道"><span class="toc-text">三、 关闭通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四、通道上的范围循环"><span class="toc-text">四、通道上的范围循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#五、非缓冲通道"><span class="toc-text">五、非缓冲通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#六、缓冲通道"><span class="toc-text">六、缓冲通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#七、双向通道"><span class="toc-text">七、双向通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#八、单向通道"><span class="toc-text">八、单向通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#九、time-包中的通道相关函数"><span class="toc-text">九、time 包中的通道相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1、time-NewTimer"><span class="toc-text">9.1、time.NewTimer()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2、timer-Stop"><span class="toc-text">9.2、timer.Stop</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3、time-After"><span class="toc-text">9.3、time.After()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十、select-语句"><span class="toc-text">十、select 语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#十一、Go-语言的-CSP-模型"><span class="toc-text">十一、Go 语言的 CSP 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1、CSP-是什么"><span class="toc-text">11.1、CSP 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2、Golang-CSP"><span class="toc-text">11.2、Golang CSP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3、Channel"><span class="toc-text">11.3、Channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4、Goroutine"><span class="toc-text">11.4、Goroutine</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5、Goroutine-调度器"><span class="toc-text">11.5、Goroutine 调度器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-6、最后"><span class="toc-text">11.6、最后</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/golang/golang.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">channel通道</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-05-26</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/golang/">golang</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="channel-通道"><a href="#channel-通道" class="headerlink" title="channel 通道"></a>channel 通道</h1><p>通道可以被认为是 Goroutines 通信的管道。类似于管道中的水从一端到另一端的流动，数据可以从一端发送到另一端，通过通道接收。</p>
<p>在前面讲 Go 语言的并发时候，我们就说过，当多个 Goroutine 想实现共享数据的时候，虽然也提供了传统的同步机制，但是 Go 语言强烈建议的是使用 Channel 通道来实现 Goroutines 之间的通信。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“不要通过共享内存来通信，而应该通过通信来共享内存” 这是一句风靡golang社区的经典语</span><br></pre></td></tr></table></figure></div>

<p>Go 语言中，要传递某个数据给另一个 goroutine(协程)，可以把这个数据封装成一个对象，然后把这个对象的指针传入某个 channel 中，另外一个 goroutine 从这个 channel 中读出这个指针，并处理其指向的内存对象。Go 从语言层面保证同一个时间只有一个 goroutine 能够访问 channel 里面的数据，为开发者提供了一种优雅简单的工具，所以 Go 的做法就是使用 channel 来通信，通过通信来传递内存数据，使得内存数据在不同的 goroutine 中传递，而不是使用共享内存来通信。</p>
<h2 id="一、-什么是通道"><a href="#一、-什么是通道" class="headerlink" title="一、 什么是通道"></a>一、 什么是通道</h2><h3 id="1-1-通道的概念"><a href="#1-1-通道的概念" class="headerlink" title="1.1 通道的概念"></a>1.1 通道的概念</h3><p>通道是什么，通道就是 goroutine 之间的通道。它可以让 goroutine 之间相互通信。</p>
<p>每个通道都有与其相关的类型。该类型是通道允许传输的数据类型。(通道的零值为 nil。nil 通道没有任何用处，因此通道必须使用类似于 map 和切片的方法来定义。)</p>
<h3 id="1-2-通道的声明"><a href="#1-2-通道的声明" class="headerlink" title="1.2 通道的声明"></a>1.2 通道的声明</h3><p>声明一个通道和定义一个变量的语法一样：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明通道</span></span><br><span class="line"><span class="keyword">var</span> 通道名 <span class="keyword">chan</span> 数据类型</span><br><span class="line"><span class="comment">//创建通道：如果通道为nil(就是不存在)，就需要先创建通道</span></span><br><span class="line">通道名 = <span class="built_in">make</span>(<span class="keyword">chan</span> 数据类型)</span><br></pre></td></tr></table></figure></div>

<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a <span class="keyword">chan</span> <span class="keyword">int</span></span><br><span class="line">	<span class="keyword">if</span> a == <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"channel 是 nil 的, 不能使用，需要先创建通道。。"</span>)</span><br><span class="line">		a = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">		fmt.Printf(<span class="string">"数据类型是： %T"</span>, a)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">channel 是 nil 的, 不能使用，需要先创建通道。。</span><br><span class="line">数据类型是： chan int</span><br></pre></td></tr></table></figure></div>

<p>也可以简短的声明：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br></pre></td></tr></table></figure></div>

<h3 id="1-3-channel-的数据类型"><a href="#1-3-channel-的数据类型" class="headerlink" title="1.3 channel 的数据类型"></a>1.3 channel 的数据类型</h3><p>channel 是引用类型的数据，在作为参数传递的时候，传递的是内存地址。</p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	fmt.Printf(<span class="string">"%T,%p\n"</span>,ch1,ch1)</span><br><span class="line"></span><br><span class="line">	test1(ch1)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test1</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	fmt.Printf(<span class="string">"%T,%p\n"</span>,ch,ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190812-154429.png" data-fancybox="group" data-caption="WX20190812-154429" class="fancybox"><img alt="WX20190812-154429" data-src="/img/golangbase/WX20190812-154429.png" class="lazyload" title="WX20190812-154429"></a></p>
<p>我们能够看到，ch 和 ch1 的地址是一样的，说明它们是同一个通道。</p>
<h3 id="1-4-通道的注意点"><a href="#1-4-通道的注意点" class="headerlink" title="1.4 通道的注意点"></a>1.4 通道的注意点</h3><p>Channel 通道在使用的时候，有以下几个注意点：</p>
<ul>
<li><p>1.用于 goroutine，传递消息的。</p>
</li>
<li><p>2.通道，每个都有相关联的数据类型,<br>nil chan，不能使用，类似于 nil map，不能直接存储键值对</p>
</li>
<li><p>3.使用通道传递数据：&lt;-<br>chan &lt;- data,发送数据到通道。向通道中写数据<br>data &lt;- chan,从通道中获取数据。从通道中读数据</p>
</li>
<li><p>4.阻塞：<br>发送数据：chan &lt;- data,阻塞的，直到另一条 goroutine，读取数据来解除阻塞<br>读取数据：data &lt;- chan,也是阻塞的。直到另一条 goroutine，写出数据解除阻塞。</p>
</li>
<li><p>5.本身 channel 就是同步的，意味着同一时间，只能有一条 goroutine 来操作。</p>
</li>
</ul>
<p>最后：通道是 goroutine 之间的连接，所以通道的发送和接收必须处在不同的 goroutine 中。</p>
<h2 id="二、通道的使用语法"><a href="#二、通道的使用语法" class="headerlink" title="二、通道的使用语法"></a>二、通道的使用语法</h2><h3 id="2-1-发送和接收"><a href="#2-1-发送和接收" class="headerlink" title="2.1 发送和接收"></a>2.1 发送和接收</h3><p>发送和接收的语法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// read from channel a</span></span><br><span class="line">a &lt;- data <span class="comment">// write to channel a</span></span><br></pre></td></tr></table></figure></div>

<p>在通道上箭头的方向指定数据是发送还是接收。</p>
<p>另外：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- a <span class="comment">//从一个channel中读取</span></span><br></pre></td></tr></table></figure></div>

<h3 id="2-2-发送和接收默认是阻塞的"><a href="#2-2-发送和接收默认是阻塞的" class="headerlink" title="2.2 发送和接收默认是阻塞的"></a>2.2 发送和接收默认是阻塞的</h3><p>一个通道发送和接收数据，默认是阻塞的。当一个数据被发送到通道时，在发送语句中被阻塞，直到另一个 Goroutine 从该通道读取数据。相对地，当从通道读取数据时，读取被阻塞，直到一个 Goroutine 将数据写入该通道。</p>
<p>这些通道的特性是帮助 Goroutines 有效地进行通信，而无需像使用其他编程语言中非常常见的显式锁或条件变量。</p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch1 <span class="keyword">chan</span> <span class="keyword">bool</span>       <span class="comment">//声明，没有创建</span></span><br><span class="line">	fmt.Println(ch1)        <span class="comment">//&lt;nil&gt;</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, ch1) <span class="comment">//chan bool</span></span><br><span class="line">	ch1 = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)   <span class="comment">//0xc0000a4000,是引用类型的数据</span></span><br><span class="line">	fmt.Println(ch1)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">			fmt.Println(<span class="string">"子goroutine中，i："</span>, i)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 循环结束后，向通道中写数据，表示要结束了。。</span></span><br><span class="line">		ch1 &lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"结束。。"</span>)</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	data := &lt;-ch1 <span class="comment">// 从ch1通道中读取数据</span></span><br><span class="line">	fmt.Println(<span class="string">"data--&gt;"</span>, data)</span><br><span class="line">	fmt.Println(<span class="string">"main。。over。。。。"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190812-153205.png" data-fancybox="group" data-caption="WX20190812-153205" class="fancybox"><img alt="WX20190812-153205" data-src="/img/golangbase/WX20190812-153205.png" class="lazyload" title="WX20190812-153205"></a></p>
<p>在上面的程序中，我们先创建了一个 chan bool 通道。然后启动了一条子 Goroutine，并循环打印 10 个数字。然后我们向通道 ch1 中写入输入 true。然后在主 goroutine 中，我们从 ch1 中读取数据。这一行代码是阻塞的，这意味着在子 Goroutine 将数据写入到该通道之前，主 goroutine 将不会执行到下一行代码。因此，我们可以通过 channel 实现子 goroutine 和主 goroutine 之间的通信。当子 goroutine 执行完毕前，主 goroutine 会因为读取 ch1 中的数据而阻塞。从而保证了子 goroutine 会先执行完毕。这就消除了对时间的需求。在之前的程序中，我们要么让主 goroutine 进入睡眠，以防止主要的 Goroutine 退出。要么通过 WaitGroup 来保证子 goroutine 先执行完毕，主 goroutine 才结束。</p>
<p>示例代码：以下代码加入了睡眠，可以更好的理解 channel 的阻塞</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>) <span class="comment">// 通道</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		fmt.Println(<span class="string">"子goroutine执行。。。"</span>)</span><br><span class="line">		time.Sleep(<span class="number">3</span> * time.Second)</span><br><span class="line">		data := &lt;-ch1 <span class="comment">// 从通道中读取数据</span></span><br><span class="line">		fmt.Println(<span class="string">"data："</span>, data)</span><br><span class="line">		done &lt;- <span class="literal">true</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="comment">// 向通道中写数据。。</span></span><br><span class="line">	time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">	ch1 &lt;- <span class="number">100</span></span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">"main。。over"</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190812-154236.png" data-fancybox="group" data-caption="WX20190812-154236" class="fancybox"><img alt="WX20190812-154236" data-src="/img/golangbase/WX20190812-154236.png" class="lazyload" title="WX20190812-154236"></a></p>
<p>再一个例子，这个程序将打印一个数字的个位数的平方和。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcSquares</span><span class="params">(number <span class="keyword">int</span>, squareop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    squareop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">calcCubes</span><span class="params">(number <span class="keyword">int</span>, cubeop <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    sum := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        digit := number % <span class="number">10</span></span><br><span class="line">        sum += digit * digit * digit</span><br><span class="line">        number /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    cubeop &lt;- sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    number := <span class="number">589</span></span><br><span class="line">    sqrch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    cubech := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> calcSquares(number, sqrch)</span><br><span class="line">    <span class="keyword">go</span> calcCubes(number, cubech)</span><br><span class="line">    squares, cubes := &lt;-sqrch, &lt;-cubech</span><br><span class="line">    fmt.Println(<span class="string">"Final output"</span>, squares + cubes)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Final output 1536</span><br></pre></td></tr></table></figure></div>

<h3 id="2-3-死锁"><a href="#2-3-死锁" class="headerlink" title="2.3 死锁"></a>2.3 死锁</h3><p>使用通道时要考虑的一个重要因素是死锁。如果 Goroutine 在一个通道上发送数据，那么预计其他的 Goroutine 应该接收数据。如果这种情况不发生，那么程序将在运行时出现死锁。</p>
<p>类似地，如果 Goroutine 正在等待从通道接收数据，那么另一些 Goroutine 将会在该通道上写入数据，否则程序将会死锁。</p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    ch &lt;- <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>报错：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br><span class="line"></span><br><span class="line">goroutine 1 [chan send]:</span><br><span class="line">main.main()</span><br><span class="line">	&#x2F;Users&#x2F;ruby&#x2F;go&#x2F;src&#x2F;l_goroutine&#x2F;demo08_chan.go:5 +0x50</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>在主流的编程语言中为了保证多线程之间共享数据安全性和一致性，都会提供一套基本的同步工具集，如锁，条件变量，原子操作等等。Go 语言标准库也毫不意外的提供了这些同步机制，使用方式也和其他语言也差不多。<br>除了这些基本的同步手段，Go 语言还提供了一种新的同步机制: Channel，它在 Go 语言中是一个像 int, float32 等的基本类型，一个 channel 可以认为是一个能够在多个 Goroutine 之间传递某一类型的数据的管道。Go 中的 channel 无论是实现机制还是使用场景都和 Java 中的 BlockingQueue 很接近。</p>
</blockquote>
<h2 id="三、-关闭通道"><a href="#三、-关闭通道" class="headerlink" title="三、 关闭通道"></a>三、 关闭通道</h2><p>发送者可以通过关闭信道，来通知接收方不会有更多的数据被发送到 channel 上。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></div>

<p>接收者可以在接收来自通道的数据时使用额外的变量来检查通道是否已经关闭。</p>
<p>语法结构：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v, ok := &lt;- ch</span><br></pre></td></tr></table></figure></div>

<blockquote>
<p>类似 map 操作，存储 key，value 键值对</p>
<p>v,ok := map[key] //根据 key 从 map 中获取 value，如果 key 存在， v 就是对应的数据，如果 key 不存在，v 是默认值</p>
</blockquote>
<p>在上面的语句中，如果 ok 的值是 true，表示成功的从通道中读取了一个数据 value。如果 ok 是 false，这意味着我们正在从一个封闭的通道读取数据。从闭通道读取的值将是通道类型的零值。</p>
<p>例如，如果通道是一个 int 通道，那么从封闭通道接收的值将为 0。</p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1)</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	子goroutine，写出数据10个</span></span><br><span class="line"><span class="comment">			每写一个，阻塞一次，主程序读取一次，解除阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	主goroutine：循环读</span></span><br><span class="line"><span class="comment">			每次读取一个，堵塞一次，子程序，写出一个，解除阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	发送发，关闭通道的---&gt;接收方，接收到的数据是该类型的零值，以及false</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//主程序中获取通道的数据</span></span><br><span class="line">	<span class="keyword">for</span>&#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">		v, ok := &lt;- ch1 <span class="comment">//其他goroutine，显示的调用close方法关闭通道。</span></span><br><span class="line">		<span class="keyword">if</span> !ok&#123;</span><br><span class="line">			fmt.Println(<span class="string">"已经读取了所有的数据，"</span>, ok)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"取出数据："</span>,v, ok)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"main...over...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="comment">// 发送方：10条数据</span></span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ;i++  &#123;</span><br><span class="line">		ch1 &lt;- i<span class="comment">//将i写入通道中</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch1) <span class="comment">//将ch1通道关闭了。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果</p>
<p><a href="/img/golangbase/WX20190813-100521.png" data-fancybox="group" data-caption="WX20190813-100521" class="fancybox"><img alt="WX20190813-100521" data-src="/img/golangbase/WX20190813-100521.png" class="lazyload" title="WX20190813-100521"></a></p>
<p>在上面的程序中，send Goroutine 将 0 到 9 写入 chl 通道，然后关闭通道。主函数里有一个无限循环。它检查通道是否在发送数据后，使用变量 ok 关闭。如果 ok 是假的，则意味着通道关闭，因此循环结束。还可以打印接收到的值和 ok 的值。</p>
<h2 id="四、通道上的范围循环"><a href="#四、通道上的范围循环" class="headerlink" title="四、通道上的范围循环"></a>四、通道上的范围循环</h2><p>我们可以循环从通道上获取数据，直到通道关闭。for 循环的 for range 形式可用于从通道接收值，直到它关闭为止。</p>
<p>使用 range 循环，示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	ch1 :=<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1)</span><br><span class="line">	<span class="comment">// for循环的for range形式可用于从通道接收值，直到它关闭为止。</span></span><br><span class="line">	<span class="keyword">for</span> v := <span class="keyword">range</span> ch1&#123;</span><br><span class="line">		fmt.Println(<span class="string">"读取数据："</span>,v)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">"main..over....."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>  &#123;</span><br><span class="line">	<span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span> ; i++ &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">		ch1 &lt;- i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch1)<span class="comment">//通知对方，通道关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190813-100915.png" data-fancybox="group" data-caption="WX20190813-100915" class="fancybox"><img alt="WX20190813-100915" data-src="/img/golangbase/WX20190813-100915.png" class="lazyload" title="WX20190813-100915"></a></p>
<h2 id="五、非缓冲通道"><a href="#五、非缓冲通道" class="headerlink" title="五、非缓冲通道"></a>五、非缓冲通道</h2><p>之前学习的所有通道基本上都没有缓冲。发送和接收到一个未缓冲的通道是阻塞的。</p>
<p>一次发送操作对应一次接收操作，对于一个 goroutine 来讲，它的一次发送，在另一个 goroutine 接收之前都是阻塞的。同样的，对于接收来讲，在另一个 goroutine 发送之前，它也是阻塞的。</p>
<h2 id="六、缓冲通道"><a href="#六、缓冲通道" class="headerlink" title="六、缓冲通道"></a>六、缓冲通道</h2><p>缓冲通道就是指一个通道，带有一个缓冲区。发送到一个缓冲通道只有在缓冲区满时才被阻塞。类似地，从缓冲通道接收的信息只有在缓冲区为空时才会被阻塞。</p>
<p>可以通过将额外的容量参数传递给 make 函数来创建缓冲通道，该函数指定缓冲区的大小。</p>
<p>语法：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">type</span>, capacity)</span><br></pre></td></tr></table></figure></div>

<p>上述语法的容量应该大于 0，以便通道具有缓冲区。默认情况下，无缓冲通道的容量为 0，因此在之前创建通道时省略了容量参数。</p>
<p>示例代码：</p>
<p>以下的代码中，chan 通道，是带有缓冲区的。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"strconv"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	非缓存通道：make(chan T)</span></span><br><span class="line"><span class="comment">	缓存通道：make(chan T ,size)</span></span><br><span class="line"><span class="comment">		缓存通道，理解为是队列：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	非缓存，发送还是接受，都是阻塞的</span></span><br><span class="line"><span class="comment">	缓存通道,缓存区的数据满了，才会阻塞状态。。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)           <span class="comment">//非缓存的通道</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ch1), <span class="built_in">cap</span>(ch1)) <span class="comment">//0 0</span></span><br><span class="line">	<span class="comment">//ch1 &lt;- 100//阻塞的，需要其他的goroutine解除阻塞，否则deadlock</span></span><br><span class="line"></span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">5</span>)        <span class="comment">//缓存的通道，缓存区大小是5</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ch2), <span class="built_in">cap</span>(ch2)) <span class="comment">//0 5</span></span><br><span class="line">	ch2 &lt;- <span class="number">100</span>                      <span class="comment">//</span></span><br><span class="line">	fmt.Println(<span class="built_in">len</span>(ch2), <span class="built_in">cap</span>(ch2)) <span class="comment">//1 5</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//ch2 &lt;- 200</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 300</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 400</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 500</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 600</span></span><br><span class="line">	fmt.Println(<span class="string">"--------------"</span>)</span><br><span class="line">	ch3 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData3(ch3)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">		v, ok := &lt;-ch3</span><br><span class="line">		<span class="keyword">if</span> !ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"读完了，，"</span>, ok)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(<span class="string">"\t读取的数据是："</span>, v)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"main...over..."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData3</span><span class="params">(ch3 <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">		ch3 &lt;- <span class="string">"数据"</span> + strconv.Itoa(i)</span><br><span class="line">		fmt.Println(<span class="string">"子goroutine，写出第"</span>, i, <span class="string">"个数据"</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">close</span>(ch3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190813-102230.png" data-fancybox="group" data-caption="WX20190813-102230" class="fancybox"><img alt="WX20190813-102230" data-src="/img/golangbase/WX20190813-102230.png" class="lazyload" title="WX20190813-102230"></a></p>
<h2 id="七、双向通道"><a href="#七、双向通道" class="headerlink" title="七、双向通道"></a>七、双向通道</h2><p>通道，channel，是用于实现 goroutine 之间的通信的。一个 goroutine 可以向通道中发送数据，另一条 goroutine 可以从该通道中获取数据。截止到现在我们所学习的通道，都是既可以发送数据，也可以读取数据，我们又把这种通道叫做双向通道。</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data := &lt;- a <span class="comment">// read from channel a</span></span><br><span class="line">a &lt;- data <span class="comment">// write to channel a</span></span><br></pre></td></tr></table></figure></div>

<h2 id="八、单向通道"><a href="#八、单向通道" class="headerlink" title="八、单向通道"></a>八、单向通道</h2><p>单向通道，也就是定向通道。</p>
<p>之前我们学习的通道都是双向通道，我们可以通过这些通道接收或者发送数据。我们也可以创建单向通道，这些通道只能发送或者接收数据。</p>
<p>双向通道，实例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	双向：</span></span><br><span class="line"><span class="comment">		chan T --&gt;</span></span><br><span class="line"><span class="comment">			chan &lt;- data,写出数据，写</span></span><br><span class="line"><span class="comment">			data &lt;- chan,获取数据，读</span></span><br><span class="line"><span class="comment">	单向：定向</span></span><br><span class="line"><span class="comment">		chan &lt;- T,</span></span><br><span class="line"><span class="comment">			只支持写，</span></span><br><span class="line"><span class="comment">		&lt;- chan T,</span></span><br><span class="line"><span class="comment">			只读</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">// 双向，可读，可写</span></span><br><span class="line">	done := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line">	<span class="keyword">go</span> sendData(ch1, done)</span><br><span class="line">	data :=&lt;- ch1 <span class="comment">//阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"子goroutine传来："</span>, data)</span><br><span class="line">	ch1 &lt;- <span class="string">"我是main。。"</span> <span class="comment">// 阻塞</span></span><br><span class="line"></span><br><span class="line">	&lt;-done</span><br><span class="line">	fmt.Println(<span class="string">"main...over...."</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//子goroutine--&gt;写数据到ch1通道中</span></span><br><span class="line"><span class="comment">//main goroutine--&gt;从ch1通道中取</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendData</span><span class="params">(ch1 <span class="keyword">chan</span> <span class="keyword">string</span>, done <span class="keyword">chan</span> <span class="keyword">bool</span>)</span></span>  &#123;</span><br><span class="line">	ch1 &lt;- <span class="string">"我是小明"</span><span class="comment">// 阻塞</span></span><br><span class="line">	data := &lt;-ch1 <span class="comment">// 阻塞</span></span><br><span class="line">	fmt.Println(<span class="string">"main goroutine传来："</span>,data)</span><br><span class="line"></span><br><span class="line">	done &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190814-101353.png" data-fancybox="group" data-caption="WX20190814-101353" class="fancybox"><img alt="WX20190814-101353" data-src="/img/golangbase/WX20190814-101353.png" class="lazyload" title="WX20190814-101353"></a></p>
<p>创建仅能发送数据的通道，示例代码：</p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		单向：定向</span></span><br><span class="line"><span class="comment">		chan &lt;- T,</span></span><br><span class="line"><span class="comment">			只支持写，</span></span><br><span class="line"><span class="comment">		&lt;- chan T,</span></span><br><span class="line"><span class="comment">			只读</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">		用于参数传递：</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)<span class="comment">//双向，读，写</span></span><br><span class="line">	<span class="comment">//ch2 := make(chan &lt;- int) // 单向，只写，不能读</span></span><br><span class="line">	<span class="comment">//ch3 := make(&lt;- chan int) //单向，只读，不能写</span></span><br><span class="line">	<span class="comment">//ch1 &lt;- 100</span></span><br><span class="line">	<span class="comment">//data :=&lt;-ch1</span></span><br><span class="line">	<span class="comment">//ch2 &lt;- 1000</span></span><br><span class="line">	<span class="comment">//data := &lt;- ch2</span></span><br><span class="line">	<span class="comment">//fmt.Println(data)</span></span><br><span class="line">	<span class="comment">//	&lt;-ch2 //invalid operation: &lt;-ch2 (receive from send-only type chan&lt;- int)</span></span><br><span class="line">	<span class="comment">//ch3 &lt;- 100</span></span><br><span class="line">	<span class="comment">//	&lt;-ch3</span></span><br><span class="line">	<span class="comment">//	ch3 &lt;- 100 //invalid operation: ch3 &lt;- 100 (send to receive-only type &lt;-chan int)</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//go fun1(ch2)</span></span><br><span class="line">	<span class="keyword">go</span> fun1(ch1)</span><br><span class="line">	data:= &lt;- ch1</span><br><span class="line">	fmt.Println(<span class="string">"fun1中写出的数据是："</span>,data)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//fun2(ch3)</span></span><br><span class="line">	<span class="keyword">go</span> fun2(ch1)</span><br><span class="line">	ch1 &lt;- <span class="number">200</span></span><br><span class="line">	fmt.Println(<span class="string">"main。。over。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该函数接收，只写的通道</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun1</span><span class="params">(ch <span class="keyword">chan</span> &lt;- <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 函数内部，对于ch只能写数据，不能读数据</span></span><br><span class="line">	ch &lt;- <span class="number">100</span></span><br><span class="line">	fmt.Println(<span class="string">"fun1函数结束。。"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fun2</span><span class="params">(ch &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span>&#123;</span><br><span class="line">	<span class="comment">//函数内部，对于ch只能读数据，不能写数据</span></span><br><span class="line">	data := &lt;- ch</span><br><span class="line">	fmt.Println(<span class="string">"fun2函数，从ch中读取的数据是："</span>,data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190814-102655.png" data-fancybox="group" data-caption="WX20190814-102655" class="fancybox"><img alt="WX20190814-102655" data-src="/img/golangbase/WX20190814-102655.png" class="lazyload" title="WX20190814-102655"></a></p>
<h2 id="九、time-包中的通道相关函数"><a href="#九、time-包中的通道相关函数" class="headerlink" title="九、time 包中的通道相关函数"></a>九、time 包中的通道相关函数</h2><p>主要就是定时器，标准库中的 Timer 让用户可以定义自己的超时逻辑，尤其是在应对 select 处理多个 channel 的超时、单 channel 读写的超时等情形时尤为方便。</p>
<p>Timer 是一次性的时间触发事件，这点与 Ticker 不同，Ticker 是按一定时间间隔持续触发时间事件。</p>
<p>Timer 常见的创建方式：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t:= time.NewTimer(d)</span><br><span class="line">t:= time.AfterFunc(d, f)</span><br><span class="line">c:= time.After(d)</span><br></pre></td></tr></table></figure></div>

<p>虽然说创建方式不同，但是原理是相同的。</p>
<p>Timer 有 3 个要素：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">定时时间：就是那个d</span><br><span class="line">触发动作：就是那个f</span><br><span class="line">时间channel： 也就是t.C</span><br></pre></td></tr></table></figure></div>

<h3 id="9-1、time-NewTimer"><a href="#9-1、time-NewTimer" class="headerlink" title="9.1、time.NewTimer()"></a>9.1、time.NewTimer()</h3><p>NewTimer()创建一个新的计时器，该计时器将在其通道上至少持续 d 之后发送当前时间。</p>
<p><a href="/img/golangbase/WX20190815-100148.png" data-fancybox="group" data-caption="WX20190815-100148" class="fancybox"><img alt="WX20190815-100148" data-src="/img/golangbase/WX20190815-100148.png" class="lazyload" title="WX20190815-100148"></a></p>
<p>它的返回值是一个 Timer。</p>
<p>源代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NewTimer creates a new Timer that will send</span></span><br><span class="line"><span class="comment">// the current time on its channel after at least duration d.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTimer</span><span class="params">(d Duration)</span> *<span class="title">Timer</span></span> &#123;</span><br><span class="line">	c := <span class="built_in">make</span>(<span class="keyword">chan</span> Time, <span class="number">1</span>)</span><br><span class="line">	t := &amp;Timer&#123;</span><br><span class="line">		C: c,</span><br><span class="line">		r: runtimeTimer&#123;</span><br><span class="line">			when: when(d),</span><br><span class="line">			f:    sendTime,</span><br><span class="line">			arg:  c,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	startTimer(&amp;t.r)</span><br><span class="line">	<span class="keyword">return</span> t</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过源代码我们可以看出，首先创建一个 channel，关联的类型为 Time，然后创建了一个 Timer 并返回。</p>
<ul>
<li>用于在指定的 Duration 类型时间后调用函数或计算表达式。</li>
<li>如果只是想指定时间之后执行,使用 time.Sleep()</li>
<li>使用 NewTimer(),可以返回的 Timer 类型在计时器到期之前,取消该计时器</li>
<li>直到使用&lt;-timer.C 发送一个值,该计时器才会过期</li>
</ul>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.func NewTimer(d Duration) *Timer</span></span><br><span class="line"><span class="comment">			创建一个计时器：d时间以后触发，go触发计时器的方法比较特别，就是在计时器的channel中发送值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//新建一个计时器：timer</span></span><br><span class="line">	timer := time.NewTimer(<span class="number">3</span> * time.Second)</span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, timer) <span class="comment">//*time.Timer</span></span><br><span class="line">	fmt.Println(time.Now())   <span class="comment">//2019-08-15 10:41:21.800768 +0800 CST m=+0.000461190</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">//此处在等待channel中的信号，执行此段代码时会阻塞3秒</span></span><br><span class="line">	ch2 := timer.C     <span class="comment">//&lt;-chan time.Time</span></span><br><span class="line">	fmt.Println(&lt;-ch2) <span class="comment">//2019-08-15 10:41:24.803471 +0800 CST m=+3.003225965</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190815-104148.png" data-fancybox="group" data-caption="WX20190815-104148" class="fancybox"><img alt="WX20190815-104148" data-src="/img/golangbase/WX20190815-104148.png" class="lazyload" title="WX20190815-104148"></a></p>
<h3 id="9-2、timer-Stop"><a href="#9-2、timer-Stop" class="headerlink" title="9.2、timer.Stop"></a>9.2、timer.Stop</h3><p>计时器停止：</p>
<p><a href="/img/golangbase/WX20190815-102436.png" data-fancybox="group" data-caption="WX20190815-102436" class="fancybox"><img alt="WX20190815-102436" data-src="/img/golangbase/WX20190815-102436.png" class="lazyload" title="WX20190815-102436"></a></p>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		1.func NewTimer(d Duration) *Timer</span></span><br><span class="line"><span class="comment">			创建一个计时器：d时间以后触发，go触发计时器的方法比较特别，就是在计时器的channel中发送值</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="comment">//新建一个计时器：timer</span></span><br><span class="line">	<span class="comment">//timer := time.NewTimer(3 * time.Second)</span></span><br><span class="line">	<span class="comment">//fmt.Printf("%T\n", timer) //*time.Timer</span></span><br><span class="line">	<span class="comment">//fmt.Println(time.Now())   //2019-08-15 10:41:21.800768 +0800 CST m=+0.000461190</span></span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	<span class="comment">////此处在等待channel中的信号，执行此段代码时会阻塞3秒</span></span><br><span class="line">	<span class="comment">//ch2 := timer.C     //&lt;-chan time.Time</span></span><br><span class="line">	<span class="comment">//fmt.Println(&lt;-ch2) //2019-08-15 10:41:24.803471 +0800 CST m=+3.003225965</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	fmt.Println(<span class="string">"-------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新建计时器，一秒后触发</span></span><br><span class="line"></span><br><span class="line">	timer2 := time.NewTimer(<span class="number">5</span> * time.Second)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//新开启一个线程来处理触发后的事件</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//等触发时的信号</span></span><br><span class="line"></span><br><span class="line">		&lt;-timer2.C</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 结束。。"</span>)</span><br><span class="line"></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="comment">//由于上面的等待信号是在新线程中，所以代码会继续往下执行，停掉计时器</span></span><br><span class="line"></span><br><span class="line">	time.Sleep(<span class="number">3</span>*time.Second)</span><br><span class="line">	stop := timer2.Stop()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> stop &#123;</span><br><span class="line"></span><br><span class="line">		fmt.Println(<span class="string">"Timer 2 停止。。"</span>)</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190815-104319.png" data-fancybox="group" data-caption="WX20190815-104319" class="fancybox"><img alt="WX20190815-104319" data-src="/img/golangbase/WX20190815-104319.png" class="lazyload" title="WX20190815-104319"></a></p>
<h3 id="9-3、time-After"><a href="#9-3、time-After" class="headerlink" title="9.3、time.After()"></a>9.3、time.After()</h3><p>在等待持续时间之后，然后在返回的通道上发送当前时间。它相当于 NewTimer(d).C。在计时器触发之前，垃圾收集器不会恢复底层计时器。如果效率有问题，使用 NewTimer 代替，并调用 Timer。如果不再需要计时器，请停止。</p>
<p><a href="/img/golangbase/WX20190815-093909.png" data-fancybox="group" data-caption="WX20190815-093909" class="fancybox"><img alt="WX20190815-093909" data-src="/img/golangbase/WX20190815-093909.png" class="lazyload" title="WX20190815-093909"></a></p>
<p>源码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// After waits for the duration to elapse and then sends the current time</span></span><br><span class="line"><span class="comment">// on the returned channel.</span></span><br><span class="line"><span class="comment">// It is equivalent to NewTimer(d).C.</span></span><br><span class="line"><span class="comment">// The underlying Timer is not recovered by the garbage collector</span></span><br><span class="line"><span class="comment">// until the timer fires. If efficiency is a concern, use NewTimer</span></span><br><span class="line"><span class="comment">// instead and call Timer.Stop if the timer is no longer needed.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">After</span><span class="params">(d Duration)</span> &lt;-<span class="title">chan</span> <span class="title">Time</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> NewTimer(d).C</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">		func After(d Duration) &lt;-chan Time</span></span><br><span class="line"><span class="comment">			返回一个通道：chan，存储的是d时间间隔后的当前时间。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	ch1 := time.After(<span class="number">3</span> * time.Second) <span class="comment">//3s后</span></span><br><span class="line">	fmt.Printf(<span class="string">"%T\n"</span>, ch1) <span class="comment">// &lt;-chan time.Time</span></span><br><span class="line">	fmt.Println(time.Now()) <span class="comment">//2019-08-15 09:56:41.529883 +0800 CST m=+0.000465158</span></span><br><span class="line">	time2 := &lt;-ch1</span><br><span class="line">	fmt.Println(time2) <span class="comment">//2019-08-15 09:56:44.532047 +0800 CST m=+3.002662179</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190815-095743.png" data-fancybox="group" data-caption="WX20190815-095743" class="fancybox"><img alt="WX20190815-095743" data-src="/img/golangbase/WX20190815-095743.png" class="lazyload" title="WX20190815-095743"></a></p>
<h2 id="十、select-语句"><a href="#十、select-语句" class="headerlink" title="十、select 语句"></a>十、select 语句</h2><p>select 是 Go 中的一个控制结构。select 语句类似于 switch 语句，但是 select 会随机执行一个可运行的 case。如果没有 case 可运行，它将阻塞，直到有 case 可运行。</p>
<p>select 语句的语法结构和 switch 语句很相似，也有 case 语句和 default 语句：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="keyword">case</span> communication clause  :</span><br><span class="line">       statement(s);</span><br><span class="line">    <span class="comment">/* 你可以定义任意数量的 case */</span></span><br><span class="line">    <span class="keyword">default</span> : <span class="comment">/* 可选 */</span></span><br><span class="line">       statement(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>说明：</p>
<ul>
<li><p>每个 case 都必须是一个通信</p>
</li>
<li><p>所有 channel 表达式都会被求值</p>
</li>
<li><p>所有被发送的表达式都会被求值</p>
</li>
<li><p>如果有多个 case 都可以运行，select 会随机公平地选出一个执行。其他不会执行。</p>
</li>
<li><p>否则：</p>
<p>如果有 default 子句，则执行该语句。</p>
<p>如果没有 default 字句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</p>
</li>
</ul>
<p>示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	分支语句：if，switch，select</span></span><br><span class="line"><span class="comment">	select 语句类似于 switch 语句，</span></span><br><span class="line"><span class="comment">		但是select会随机执行一个可运行的case。</span></span><br><span class="line"><span class="comment">		如果没有case可运行，它将阻塞，直到有case可运行。</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line"></span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		ch2 &lt;- <span class="number">200</span></span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">		ch1 &lt;- <span class="number">100</span></span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> num1 := &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">"ch1中取数据。。"</span>, num1)</span><br><span class="line">	<span class="keyword">case</span> num2, ok := &lt;-ch2:</span><br><span class="line">		<span class="keyword">if</span> ok &#123;</span><br><span class="line">			fmt.Println(<span class="string">"ch2中取数据。。"</span>, num2)</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			fmt.Println(<span class="string">"ch2通道已经关闭。。"</span>)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：可能执行第一个 case，打印 100，也可能执行第二个 case，打印 200。(多运行几次，结果就不同了)</p>
<p><a href="/img/golangbase/WX20190816-104608.png" data-fancybox="group" data-caption="WX20190816-104608" class="fancybox"><img alt="WX20190816-104608" data-src="/img/golangbase/WX20190816-104608.png" class="lazyload" title="WX20190816-104608"></a></p>
<p>select 语句结合 time 包的和 chan 相关函数，示例代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"fmt"</span></span><br><span class="line">	<span class="string">"time"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	ch1 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">	ch2 := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//go func() &#123;</span></span><br><span class="line">	<span class="comment">//	ch1 &lt;- 100</span></span><br><span class="line">	<span class="comment">//&#125;()</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">select</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch1:</span><br><span class="line">		fmt.Println(<span class="string">"case1可以执行。。"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-ch2:</span><br><span class="line">		fmt.Println(<span class="string">"case2可以执行。。"</span>)</span><br><span class="line">	<span class="keyword">case</span> &lt;-time.After(<span class="number">3</span> * time.Second):</span><br><span class="line">		fmt.Println(<span class="string">"case3执行。。timeout。。"</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">//default:</span></span><br><span class="line">	<span class="comment">//	fmt.Println("执行了default。。")</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>运行结果：</p>
<p><a href="/img/golangbase/WX20190816-104450.png" data-fancybox="group" data-caption="WX20190816-104450" class="fancybox"><img alt="WX20190816-104450" data-src="/img/golangbase/WX20190816-104450.png" class="lazyload" title="WX20190816-104450"></a></p>
<h2 id="十一、Go-语言的-CSP-模型"><a href="#十一、Go-语言的-CSP-模型" class="headerlink" title="十一、Go 语言的 CSP 模型"></a>十一、Go 语言的 CSP 模型</h2><p>go 语言的最大两个亮点，一个是 goroutine，一个就是 chan 了。二者合体的典型应用 CSP，基本就是大家认可的并行开发神器，简化了并行程序的开发难度，我们来看一下 CSP。</p>
<h3 id="11-1、CSP-是什么"><a href="#11-1、CSP-是什么" class="headerlink" title="11.1、CSP 是什么"></a>11.1、CSP 是什么</h3><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，是一个很强大的并发数据模型，是上个世纪七十年代提出的，用于描述两个独立的并发实体通过共享的通讯 channel(管道)进行通信的并发模型。相对于 Actor 模型，CSP 中 channel 是第一类对象，它不关注发送消息的实体，而关注与发送消息时使用的 channel。</p>
<p>严格来说，CSP 是一门形式语言（类似于 ℷ calculus），用于描述并发系统中的互动模式，也因此成为一众面向并发的编程语言的理论源头，并衍生出了 Occam/Limbo/Golang…</p>
<p>而具体到编程语言，如 Golang，其实只用到了 CSP 的很小一部分，即理论中的 Process/Channel（对应到语言中的 goroutine/channel）：这两个并发原语之间没有从属关系， Process 可以订阅任意个 Channel，Channel 也并不关心是哪个 Process 在利用它进行通信；Process 围绕 Channel 进行读写，形成一套有序阻塞和可预测的并发模型。</p>
<h3 id="11-2、Golang-CSP"><a href="#11-2、Golang-CSP" class="headerlink" title="11.2、Golang CSP"></a>11.2、Golang CSP</h3><p>与主流语言通过共享内存来进行并发控制方式不同，Go 语言采用了 CSP 模式。这是一种用于描述两个独立的并发实体通过共享的通讯 Channel（管道）进行通信的并发模型。</p>
<p>Golang 就是借用 CSP 模型的一些概念为之实现并发进行理论支持，其实从实际上出发，go 语言并没有，完全实现了 CSP 模型的所有理论，仅仅是借用了 process 和 channel 这两个概念。process 是在 go 语言上的表现就是 goroutine 是实际并发执行的实体，每个实体之间是通过 channel 通讯来实现数据共享。</p>
<p>Go 语言的 CSP 模型是由协程 Goroutine 与通道 Channel 实现：</p>
<ul>
<li>Go 协程 goroutine: 是一种轻量线程，它不是操作系统的线程，而是将一个操作系统线程分段使用，通过调度器实现协作式调度。是一种绿色线程，微线程，它与 Coroutine 协程也有区别，能够在发现堵塞后启动新的微线程。</li>
<li>通道 channel: 类似 Unix 的 Pipe，用于协程之间通讯和同步。协程之间虽然解耦，但是它们和 Channel 有着耦合。</li>
</ul>
<h3 id="11-3、Channel"><a href="#11-3、Channel" class="headerlink" title="11.3、Channel"></a>11.3、Channel</h3><p>Goroutine 和 channel 是 Go 语言并发编程的 两大基石。Goroutine 用于执行并发任务，channel 用于 goroutine 之间的同步、通信。</p>
<p>Channel 在 gouroutine 间架起了一条管道，在管道里传输数据，实现 gouroutine 间的通信；由于它是线程安全的，所以用起来非常方便；channel 还提供 “先进先出” 的特性；它还能影响 goroutine 的阻塞和唤醒。</p>
<p>相信大家一定见过一句话：</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>不要通过共享内存来通信，而要通过通信来实现内存共享。</p>
<p>这就是 Go 的并发哲学，它依赖 CSP 模型，基于 channel 实现。</p>
<p><strong>channel 实现 CSP</strong></p>
<p>Channel 是 Go 语言中一个非常重要的类型，是 Go 里的第一对象。通过 channel，Go 实现了通过通信来实现内存共享。Channel 是在多个 goroutine 之间传递数据和同步的重要手段。</p>
<p>使用原子函数、读写锁可以保证资源的共享访问安全，但使用 channel 更优雅。</p>
<p>channel 字面意义是 “通道”，类似于 Linux 中的管道。声明 channel 的语法如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span> T <span class="comment">// 声明一个双向通道</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- T <span class="comment">// 声明一个只能用于发送的通道</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> T <span class="comment">// 声明一个只能用于接收的通道</span></span><br></pre></td></tr></table></figure></div>

<p>单向通道的声明，用 <code>&lt;-</code> 来表示，它指明通道的方向。你只要明白，代码的书写顺序是从左到右就马上能掌握通道的方向是怎样的。</p>
<p>因为 channel 是一个引用类型，所以在它被初始化之前，它的值是 nil，channel 使用 make 函数进行初始化。可以向它传递一个 int 值，代表 channel 缓冲区的大小（容量），构造出来的是一个缓冲型的 channel；不传或传 0 的，构造的就是一个非缓冲型的 channel。</p>
<p>两者有一些差别：非缓冲型 channel 无法缓冲元素，对它的操作一定顺序是 “发送 -&gt; 接收 -&gt; 发送 -&gt; 接收 -&gt; ……”，如果想连续向一个非缓冲 chan 发送 2 个元素，并且没有接收的话，第一次一定会被阻塞；对于缓冲型 channel 的操作，则要 “宽松” 一些，毕竟是带了 “缓冲” 光环。</p>
<p><a href="/img/golangbase/channel.png" data-fancybox="group" data-caption="channel" class="fancybox"><img alt="channel" data-src="/img/golangbase/channel.png" class="lazyload" title="channel"></a></p>
<p>对 chan 的发送和接收操作都会在编译期间转换成为底层的发送接收函数。</p>
<p>Channel 分为两种：带缓冲、不带缓冲。对不带缓冲的 channel 进行的操作实际上可以看作 “同步模式”，带缓冲的则称为 “异步模式”。</p>
<p>同步模式下，发送方和接收方要同步就绪，只有在两者都 ready 的情况下，数据才能在两者间传输（后面会看到，实际上就是内存拷贝）。否则，任意一方先行进行发送或接收操作，都会被挂起，等待另一方的出现才能被唤醒。</p>
<p>异步模式下，在缓冲槽可用的情况下（有剩余容量），发送和接收操作都可以顺利进行。否则，操作的一方（如写入）同样会被挂起，直到出现相反操作（如接收）才会被唤醒。</p>
<p>小结一下：同步模式下，必须要使发送方和接收方配对，操作才会成功，否则会被阻塞；异步模式下，缓冲槽要有剩余容量，操作才会成功，否则也会被阻塞。</p>
<p>简单来说，CSP 模型由并发执行的实体（线程或者进程或者协程）所组成，实体之间通过发送消息进行通信，<br>这里发送消息时使用的就是通道，或者叫 channel。</p>
<p>CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论，goroutine 对应 CSP 中并发执行的实体，channel 也就对应着 CSP 中的 channel。</p>
<h3 id="11-4、Goroutine"><a href="#11-4、Goroutine" class="headerlink" title="11.4、Goroutine"></a>11.4、Goroutine</h3><p>Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine 是一种运行在用户态的用户线程，类似于 greenthread，go 底层选择使用 coroutine 的出发点是因为，它具有以下特点：</p>
<ul>
<li>用户空间 避免了内核态和用户态的切换导致的成本</li>
<li>可以由语言和框架层进行调度</li>
<li>更小的栈空间允许创建大量的实例</li>
</ul>
<p>可以看到第二条 用户空间线程的调度不是由操作系统来完成的，像在 java 1.3 中使用的 greenthread 的是由 JVM 统一调度的(后 java 已经改为内核线程)，还有在 ruby 中的 fiber(半协程) 是需要在重新中自己进行调度的，而 goroutine 是在 golang 层面提供了调度器，并且对网络 IO 库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。</p>
<h3 id="11-5、Goroutine-调度器"><a href="#11-5、Goroutine-调度器" class="headerlink" title="11.5、Goroutine 调度器"></a>11.5、Goroutine 调度器</h3><p>Go 并发调度: G-P-M 模型</p>
<p>在操作系统提供的内核线程之上，Go 搭建了一个特有的两级线程模型。goroutine 机制实现了 M : N 的线程模型，goroutine 机制是协程（coroutine）的一种实现，golang 内置的调度器，可以让多核 CPU 中每个 CPU 执行一个协程。</p>
<p><a href="/img/golangbase/goroutine2.png" data-fancybox="group" data-caption="goroutine2" class="fancybox"><img alt="goroutine2" data-src="/img/golangbase/goroutine2.png" class="lazyload" title="goroutine2"></a></p>
<h3 id="11-6、最后"><a href="#11-6、最后" class="headerlink" title="11.6、最后"></a>11.6、最后</h3><p>Golang 的 channel 将 goroutine 隔离开，并发编程的时候可以将注意力放在 channel 上。在一定程度上，这个和消息队列的解耦功能还是挺像的。如果大家感兴趣，还是来看看 channel 的源码吧，对于更深入地理解 channel 还是挺有用的。</p>
<p>Go 通过 channel 实现 CSP 通信模型，主要用于 goroutine 之间的消息传递和事件通知。</p>
<p>有了 channel 和 goroutine 之后，Go 的并发编程变得异常容易和安全，得以让程序员把注意力留到业务上去，实现开发效率的提升。</p>
<p>要知道，技术并不是最重要的，它只是实现业务的工具。一门高效的开发语言让你把节省下来的时间，留着去做更有意义的事情，比如写写文章。</p>
<blockquote>
<p>CSP 最早是由 Tony Hoare 在 1977 年提出，据说老爷子至今仍在更新这个理论模型，有兴趣的朋友可以自行查阅电子版本：<a href="http://www.usingcsp.com/cspbook.pdf。" target="_blank" rel="noopener">http://www.usingcsp.com/cspbook.pdf。</a></p>
</blockquote>
<p>参考文档：<a href="https://learnku.com/articles/32142" target="_blank" rel="noopener">https://learnku.com/articles/32142</a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wangguangatap</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wangguangatap.github.io/2020/01/27/channel/">https://wangguangatap.github.io/2020/01/27/channel/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://wangguangatap.github.io/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangguangatap.github.io">星脉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/">服务器    </a><a class="post-meta__tags" href="/tags/Golang/">Golang    </a></div><div class="post_share"><div class="social-share" data-image="/img/golang/golang.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/27/goroutine/"><img class="prev_cover lazyload" data-src="/img/golang/golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>Go语言并发Goroutine</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/27/Go%E8%AF%AD%E8%A8%80%E5%8F%8D%E5%B0%84/"><img class="next_cover lazyload" data-src="/img/golang/golang.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>Go语言反射</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/27/并发Goroutine/" title="(二十一)并发Goroutine"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">(二十一)并发Goroutine</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/golang/" title="Golang基础"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">Golang基础</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/file/" title="file操作"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">file操作</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/goroutine/" title="Go语言并发Goroutine"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">Go语言并发Goroutine</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/Go语言反射/" title="Go语言反射"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">Go语言反射</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/安装Goland开发工具/" title="(一)安装 Goland 开发工具"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">(一)安装 Goland 开发工具</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By wangguangatap</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>