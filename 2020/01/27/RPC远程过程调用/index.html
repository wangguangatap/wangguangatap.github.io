<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>微服务：(四)RPC远程过程调用 | 星脉</title><meta name="description" content="微服务：(四)RPC远程过程调用"><meta name="keywords" content="Golang,微服务"><meta name="author" content="wangguangatap"><meta name="copyright" content="wangguangatap"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="微服务：(四)RPC远程过程调用"><meta name="twitter:description" content="微服务：(四)RPC远程过程调用"><meta name="twitter:image" content="https://wangguangatap.github.io/img/weifuwu/weifuwu.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="微服务：(四)RPC远程过程调用"><meta property="og:url" content="https://wangguangatap.github.io/2020/01/27/RPC%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"><meta property="og:site_name" content="星脉"><meta property="og:description" content="微服务：(四)RPC远程过程调用"><meta property="og:image" content="https://wangguangatap.github.io/img/weifuwu/weifuwu.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://wangguangatap.github.io/2020/01/27/RPC%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"><link rel="prev" title="微服务：(三)微服务管理(下)" href="https://wangguangatap.github.io/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86(%E4%B8%8B)/"><link rel="next" title="微服务：(五)gRPC远程调用机制介绍" href="https://wangguangatap.github.io/2020/01/27/gRPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">星脉</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">18</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">7</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#RPC-远程过程调用"><span class="toc_mobile_items-text">RPC 远程过程调用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、RPC-简介及原理介绍"><span class="toc_mobile_items-text">一、RPC 简介及原理介绍</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1、背景"><span class="toc_mobile_items-text">1.1、背景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2、本地过程调用"><span class="toc_mobile_items-text">1.2、本地过程调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3、问题及解决方法"><span class="toc_mobile_items-text">1.3、问题及解决方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4、RPC-简介"><span class="toc_mobile_items-text">1.4、RPC 简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5、RPC-设计组成"><span class="toc_mobile_items-text">1.5、RPC 设计组成</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-6、RPC-原理及调用步骤"><span class="toc_mobile_items-text">1.6、RPC 原理及调用步骤</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-7、RPC-涉及到的相关技术"><span class="toc_mobile_items-text">1.7、RPC 涉及到的相关技术</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、Go-语言实现-RPC-编程"><span class="toc_mobile_items-text">二、Go 语言实现 RPC 编程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1、RPC-官方库"><span class="toc_mobile_items-text">2.1、RPC 官方库</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2、net-rpc-库实现-RPC-调用编程"><span class="toc_mobile_items-text">2.2、net&#x2F;rpc 库实现 RPC 调用编程</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-1、服务定义及暴露"><span class="toc_mobile_items-text">2.2.1、服务定义及暴露</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-2、注册服务及监听请求"><span class="toc_mobile_items-text">2.2.2、注册服务及监听请求</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-3、客户端调用"><span class="toc_mobile_items-text">2.2.3、客户端调用</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#2-2-4、多参数的请求调用参数传递"><span class="toc_mobile_items-text">2.2.4、多参数的请求调用参数传递</span></a></li></ol></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#三、RPC-与-Protobuf-结合使用"><span class="toc_mobile_items-text">三、RPC 与 Protobuf 结合使用</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-1、传输数据格式定义"><span class="toc_mobile_items-text">3.1、传输数据格式定义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-2、Protobuf-格式数据与-RPC-结合"><span class="toc_mobile_items-text">3.2、Protobuf 格式数据与 RPC 结合</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#3-3、运行结果"><span class="toc_mobile_items-text">3.3、运行结果</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#RPC-远程过程调用"><span class="toc-text">RPC 远程过程调用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、RPC-简介及原理介绍"><span class="toc-text">一、RPC 简介及原理介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、背景"><span class="toc-text">1.1、背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、本地过程调用"><span class="toc-text">1.2、本地过程调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、问题及解决方法"><span class="toc-text">1.3、问题及解决方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4、RPC-简介"><span class="toc-text">1.4、RPC 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5、RPC-设计组成"><span class="toc-text">1.5、RPC 设计组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6、RPC-原理及调用步骤"><span class="toc-text">1.6、RPC 原理及调用步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-7、RPC-涉及到的相关技术"><span class="toc-text">1.7、RPC 涉及到的相关技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Go-语言实现-RPC-编程"><span class="toc-text">二、Go 语言实现 RPC 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、RPC-官方库"><span class="toc-text">2.1、RPC 官方库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、net-rpc-库实现-RPC-调用编程"><span class="toc-text">2.2、net&#x2F;rpc 库实现 RPC 调用编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1、服务定义及暴露"><span class="toc-text">2.2.1、服务定义及暴露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2、注册服务及监听请求"><span class="toc-text">2.2.2、注册服务及监听请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3、客户端调用"><span class="toc-text">2.2.3、客户端调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4、多参数的请求调用参数传递"><span class="toc-text">2.2.4、多参数的请求调用参数传递</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三、RPC-与-Protobuf-结合使用"><span class="toc-text">三、RPC 与 Protobuf 结合使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1、传输数据格式定义"><span class="toc-text">3.1、传输数据格式定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2、Protobuf-格式数据与-RPC-结合"><span class="toc-text">3.2、Protobuf 格式数据与 RPC 结合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3、运行结果"><span class="toc-text">3.3、运行结果</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/weifuwu/weifuwu.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">微服务：(四)RPC远程过程调用</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-01</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="RPC-远程过程调用"><a href="#RPC-远程过程调用" class="headerlink" title="RPC 远程过程调用"></a>RPC 远程过程调用</h1><h2 id="一、RPC-简介及原理介绍"><a href="#一、RPC-简介及原理介绍" class="headerlink" title="一、RPC 简介及原理介绍"></a>一、RPC 简介及原理介绍</h2><h3 id="1-1、背景"><a href="#1-1、背景" class="headerlink" title="1.1、背景"></a>1.1、背景</h3><p>在前面的课程《Go 语言微服务理论与实践课程》课程中，我们已经学习了微服务的理论知识，了解了微服务实践中需要解决哪些问题。<br>从本篇技术文档开始，我们进入新的微服务内容的学习。在本系列课程中，我们会着重讲框架的内容，主要包括两个：gRPC 框架、go-micro 框架。</p>
<p>首先来学习 gRPC 框架相关的内容。</p>
<h3 id="1-2、本地过程调用"><a href="#1-2、本地过程调用" class="headerlink" title="1.2、本地过程调用"></a>1.2、本地过程调用</h3><p>让我们先来看看正常情况下程序的执行和调用情况。例如有如下 go 语言代码：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> a, b <span class="keyword">int</span></span><br><span class="line">	a = <span class="number">1</span></span><br><span class="line">	b = <span class="number">2</span></span><br><span class="line">	c := Add(a, b)</span><br><span class="line">	fmt.Println(<span class="string">"计算结果:"</span>, c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Add</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述的 Go 语言代码中，我们定义了一个 Add 方法用于实现两个数相加的功能，在 main 方法中通过调用 Add 方法实现了计算两个变量之和的操作。整个过程涉及到变量值入栈，出栈，赋值等操作，最后将出栈的计算结果返回并赋值给 c 变量。</p>
<p>总结说来，本地程序调用的过程大致可以分为几个步骤和阶段：</p>
<ul>
<li>开发者开发好的程序，并进行编译，编译成机器认可的可执行文件。</li>
<li>运行可执行文件，调用对应的功能方法，期间会读取可执行文件中国的机器指令，进行入栈，出栈赋值等操作。此时，计算机由可执行程序所在的进程控制。</li>
<li>调用结束，所有的内存数据出栈，程序执行结束。计算机继续由操作系统进行控制。</li>
</ul>
<h3 id="1-3、问题及解决方法"><a href="#1-3、问题及解决方法" class="headerlink" title="1.3、问题及解决方法"></a>1.3、问题及解决方法</h3><p>上文我们已经说过，远程过程调用是在两台或者多台不同的物理机器上实现的调用，其间要跨越网络进行调用。因此，我们再想通过前文本地方法调用的形式完成功能调用，就无法实现了，因为编译器无法通过编译的可执行文件来调用远程机器上的程序方法。因此需要采用 RPC 的方式来实现远端服务器上的程序方法的调用。</p>
<p>RPC 技术内部原理是通过两种技术的组合来实现的：<strong>本地方法调用 和 网络通信技术。</strong></p>
<h3 id="1-4、RPC-简介"><a href="#1-4、RPC-简介" class="headerlink" title="1.4、RPC 简介"></a>1.4、RPC 简介</h3><p>在上述本地过程调用的例子中，我们是在一台计算机上执行了计算机上的程序，完成调用。随着计算机技术的发展和需求场景的变化，有时就需要从一台计算机上执行另外一台计算机上的程序的需求，因此后来又发展出来了 RPC 技术。特别是目前随着互联网技术的快速迭代和发展，用户和需求几乎都是以指数式的方式在高速增长，这个时候绝大多数情况下程序都是部署在多台机器上，就需要在调用其他物理机器上的程序的情况。</p>
<p>RPC 是 Remote Procedure Call Protocol 单词首字母的缩写，简称为：RPC，翻译成中文叫远程过程调用协议。所谓远程过程调用，通俗的理解就是可以在本地程序中调用运行在另外一台服务器上的程序的功能方法。这种调用的过程跨越了物理服务器的限制，是在网络中完成的，在调用远端服务器上程序的过程中，本地程序等待返回调用结果，直到远端程序执行完毕，将结果进行返回到本地，最终完成一次完整的调用。</p>
<p>需要强调的是：<strong>远程过程调用指的是调用远端服务器上的程序的方法整个过程。</strong></p>
<h3 id="1-5、RPC-设计组成"><a href="#1-5、RPC-设计组成" class="headerlink" title="1.5、RPC 设计组成"></a>1.5、RPC 设计组成</h3><p>RPC 技术在架构设计上有四部分组成，分别是：<strong>客户端、客户端存根、服务端、服务端存根。</strong></p>
<p>这里提到了<strong>客户端</strong>和<strong>服务端</strong>的概念，其属于程序设计架构的一种方式，在现代的计算机软件程序架构设计上，大方向上分为两种方向，分别是：<strong>B/S 架构</strong>、<strong>C/S 架构</strong>。B/S 架构指的是浏览器到服务器交互的架构方式，另外一种是在计算机上安装一个单独的应用，称之为客户端，与服务器交互的模式。</p>
<p>由于在服务的调用过程中，有一方是发起调用方，另一方是提供服务方。因此，我们把服务发起方称之为客户端，把服务提供方称之为服务端。以下是对 RPC 的四种角色的解释和说明：</p>
<ul>
<li><p><strong>客户端(Client)：</strong>服务调用发起方，也称为服务消费者。</p>
</li>
<li><p><strong>客户端存根(Client Stub)：</strong>该程序运行在客户端所在的计算机机器上，主要用来存储要调用的服务器的地址，另外，该程序还负责将客户端请求远端服务器程序的数据信息打包成数据包，通过网络发送给服务端 Stub 程序；其次，还要接收服务端 Stub 程序发送的调用结果数据包，并解析返回给客户端。</p>
</li>
<li><p><strong>服务端(Server)：</strong>远端的计算机机器上运行的程序，其中有客户端要调用的方法。</p>
</li>
<li><p><strong>服务端存根(Server Stub)：</strong>接收客户 Stub 程序通过网络发送的请求消息数据包，并调用服务端中真正的程序功能方法，完成功能调用；其次，将服务端执行调用的结果进行数据处理打包发送给客户端 Stub 程序。</p>
</li>
</ul>
<h3 id="1-6、RPC-原理及调用步骤"><a href="#1-6、RPC-原理及调用步骤" class="headerlink" title="1.6、RPC 原理及调用步骤"></a>1.6、RPC 原理及调用步骤</h3><p>了解完了 RPC 技术的组成结构我们来看一下具体是如何实现客户端到服务端的调用的。实际上，如果我们想要在网络中的任意两台计算机上实现远程调用过程，要解决很多问题，比如：</p>
<ul>
<li>两台物理机器在网络中要建立稳定可靠的通信连接。</li>
<li>两台服务器的通信协议的定义问题，即两台服务器上的程序如何识别对方的请求和返回结果。也就是说两台计算机必须都能够识别对方发来的信息，并且能够识别出其中的请求含义和返回含义，然后才能进行处理。这其实就是通信协议所要完成的工作。</li>
</ul>
<p>让我们来看看 RPC 具体是如何解决这些问题的，RPC 具体的调用步骤图如下：</p>
<p><a href="/img/weifuwu/WX20190726-151825@2x.png" data-fancybox="group" data-caption="RPC调用步骤图" class="fancybox"><img alt="RPC调用步骤图" title="RPC调用步骤图" data-src="/img/weifuwu/WX20190726-151825@2x.png" class="lazyload"></a></p>
<p>在上述图中，通过 1-10 的步骤图解的形式，说明了 RPC 每一步的调用过程。具体描述为：</p>
<ul>
<li><p>1、客户端想要发起一个远程过程调用，首先通过调用本地客户端 Stub 程序的方式调用想要使用的功能方法名；</p>
</li>
<li><p>2、客户端 Stub 程序接收到了客户端的功能调用请求，<strong>将客户端请求调用的方法名，携带的参数等信息做序列化操作，并打包成数据包。</strong></p>
</li>
<li><p>3、客户端 Stub 查找到远程服务器程序的 IP 地址，调用 Socket 通信协议，通过网络发送给服务端。</p>
</li>
<li><p>4、服务端 Stub 程序接收到客户端发送的数据包信息，并<strong>通过约定好的协议将数据进行反序列化，得到请求的方法名和请求参数等信息。</strong></p>
</li>
<li><p>5、服务端 Stub 程序准备相关数据，<strong>调用本地 Server 对应的功能方法进行，并传入相应的参数，进行业务处理。</strong></p>
</li>
<li><p>6、服务端程序根据已有业务逻辑执行调用过程，待业务执行结束，将执行结果返回给服务端 Stub 程序。</p>
</li>
<li><p>7、服务端 Stub 程序<strong>将程序调用结果按照约定的协议进行序列化，</strong>并通过网络发送回客户端 Stub 程序。</p>
</li>
<li><p>8、客户端 Stub 程序接收到服务端 Stub 发送的返回数据，<strong>对数据进行反序列化操作，</strong>并将调用返回的数据传递给客户端请求发起者。</p>
</li>
<li><p>9、客户端请求发起者得到调用结果，整个 RPC 调用过程结束。</p>
</li>
</ul>
<h3 id="1-7、RPC-涉及到的相关技术"><a href="#1-7、RPC-涉及到的相关技术" class="headerlink" title="1.7、RPC 涉及到的相关技术"></a>1.7、RPC 涉及到的相关技术</h3><p>通过上文一系列的文字描述和讲解，我们已经了解了 RPC 的由来和 RPC 整个调用过程。我们可以看到 RPC 是一系列操作的集合，其中涉及到很多对数据的操作，以及网络通信。因此，我们对 RPC 中涉及到的技术做一个总结和分析：</p>
<ul>
<li><p><strong>1、动态代理技术：</strong> 上文中我们提到的 Client Stub 和 Sever Stub 程序，在具体的编码和开发实践过程中，都是使用动态代理技术自动生成的一段程序。</p>
</li>
<li><p><strong>2、序列化和反序列化：</strong> 在 RPC 调用的过程中，我们可以看到数据需要在一台机器上传输到另外一台机器上。在互联网上，所有的数据都是以字节的形式进行传输的。而我们在编程的过程中，往往都是使用数据对象，因此想要在网络上将数据对象和相关变量进行传输，就需要对数据对象做序列化和反序列化的操作。</p>
<ul>
<li><p><strong>序列化：</strong>把对象转换为字节序列的过程称为对象的序列化，也就是编码的过程。</p>
</li>
<li><p><strong>反序列化：</strong>把字节序列恢复为对象的过程称为对象的反序列化，也就是解码的过程。</p>
</li>
</ul>
</li>
</ul>
<p>我们常见的 Json,XML 等相关框架都可以对数据做序列化和反序列化编解码操作。同时，在之前的《Go 语言微服务理论与实践》课程中，我们已经学习过 Protobuf 协议，这也是一种数据编解码的协议，在 RPC 框架中使用的更广泛。</p>
<h2 id="二、Go-语言实现-RPC-编程"><a href="#二、Go-语言实现-RPC-编程" class="headerlink" title="二、Go 语言实现 RPC 编程"></a>二、Go 语言实现 RPC 编程</h2><p>上节课我们对 RPC 知识做了介绍，讲解了 RPC 的原理，通过图示方式讲解了 RPC 的内部执行过程。本节课，我们继续来学习 RPC 相关的内容。</p>
<h3 id="2-1、RPC-官方库"><a href="#2-1、RPC-官方库" class="headerlink" title="2.1、RPC 官方库"></a>2.1、RPC 官方库</h3><p>在 Go 语言官方网站的 pkg 说明中，提供了官方支持的 rpc 包，具体链接如下：<a href="https://golang.org/pkg/net/rpc/" target="_blank" rel="noopener">https://golang.org/pkg/net/rpc/</a>。官方提供的 rpc 包完整的包名是：<strong>net/rpc</strong>。根据官方的解释，rpc 包主要是提供通过网络访问一个对象方法的功能。</p>
<p>本节课，我们就来学习如何使用 go 语言官方提供的 RPC 包实现 RPC 调用编码。</p>
<h3 id="2-2、net-rpc-库实现-RPC-调用编程"><a href="#2-2、net-rpc-库实现-RPC-调用编程" class="headerlink" title="2.2、net/rpc 库实现 RPC 调用编程"></a>2.2、net/rpc 库实现 RPC 调用编程</h3><p>前文我们已经讲过 rpc 调用有两个参与者，分别是：<strong>客户端（client）和服务器（server）</strong>。</p>
<p>首先是提供方法暴露的一方–服务器。</p>
<h4 id="2-2-1、服务定义及暴露"><a href="#2-2-1、服务定义及暴露" class="headerlink" title="2.2.1、服务定义及暴露"></a>2.2.1、服务定义及暴露</h4><p>在编程实现过程中，服务器端需要注册结构体对象，然后通过对象所属的方法暴露给调用者，从而提供服务，该方法称之为<strong>输出方法</strong>，此输出方法可以被远程调用。当然，在定义输出方法时，能够被远程调用的方法需要遵循一定的规则。我们通过代码进行讲解：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t *T)</span> <span class="title">MethodName</span><span class="params">(request T1,response *T2)</span> <span class="title">error</span></span></span><br></pre></td></tr></table></figure></div>

<p>上述代码是 go 语言官方给出的对外暴露的服务方法的定义标准，其中包含了主要的几条规则，分别是：</p>
<ul>
<li>1、对外暴露的方法有且只能有两个参数，这个两个参数只能是输出类型或内建类型，两种类型中的一种。</li>
<li>2、方法的第二个参数必须是指针类型。</li>
<li>3、方法的返回类型为 error。</li>
<li>4、方法的类型是可输出的。</li>
<li>5、方法本身也是可输出的。</li>
</ul>
<p>我们举例说明：假设目前我们有一个需求，给出一个 float 类型变量，作为圆形的半径，要求通过 RPC 调用，返回对应的圆形面积。具体的编程实现思路如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> MathUtil <span class="keyword">struct</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该方法向外暴露：提供计算圆形面积的服务</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mu *MathUtil)</span> <span class="title">CalculateCircleArea</span><span class="params">(req <span class="keyword">float32</span>, resp *<span class="keyword">float32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*resp = math.Pi * req * req <span class="comment">//圆形的面积 s = π * r * r</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">//返回类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述的案例中，我们可以看到：</p>
<ul>
<li>1、Calculate 方法是服务对象 MathUtil 向外提供的服务方法，该方法用于接收传入的圆形半径数据，计算圆形面积并返回。</li>
<li>2、第一个参数 req 代表的是调用者（client）传递提供的参数。</li>
<li>3、第二个参数 resp 代表要返回给调用者的计算结果，必须是指针类型。</li>
<li>4、正常情况下，方法的返回值为是 error，为 nil。如果遇到异常或特殊情况，则 error 将作为一个字符串返回给调用者，此时，resp 参数就不会再返回给调用者。</li>
</ul>
<p>至此为止，已经实现了服务端的功能定义，接下来就是让服务代码生效，需要将服务进行注册，并启动请求处理。</p>
<h4 id="2-2-2、注册服务及监听请求"><a href="#2-2-2、注册服务及监听请求" class="headerlink" title="2.2.2、注册服务及监听请求"></a>2.2.2、注册服务及监听请求</h4><p><strong>net/rpc 包</strong>为我们提供了注册服务和处理请求的一系列方法,结合本案例实现注册及处理逻辑，如下所示：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、初始化指针数据类型</span></span><br><span class="line">mathUtil := <span class="built_in">new</span>(MathUtil) <span class="comment">//初始化指针数据类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、调用net/rpc包的功能将服务对象进行注册</span></span><br><span class="line">err := rpc.Register(mathUtil)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、通过该函数把mathUtil中提供的服务注册到HTTP协议上，方便调用者可以利用http的方式进行数据传递</span></span><br><span class="line">rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line"><span class="comment">//4、在特定的端口进行监听</span></span><br><span class="line">listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> http.Serve(listen, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></div>

<p>经过服务注册和监听处理，RPC 调用过程中的服务端实现就已经完成了。接下来需要实现的是客户端请求代码的实现。</p>
<h4 id="2-2-3、客户端调用"><a href="#2-2-3、客户端调用" class="headerlink" title="2.2.3、客户端调用"></a>2.2.3、客户端调用</h4><p>在服务端是通过 Http 的端口监听方式等待连接的，因此在客户端就需要通过 http 连接，首先与服务端实现连接。</p>
<ul>
<li><p>客户端连接服务端</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">"localhost:8081"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>远端方法调用<br>客户端成功连接服务端以后，就可以通过方法调用调用服务端的方法，具体调用方法如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> req <span class="keyword">float32</span> <span class="comment">//请求值</span></span><br><span class="line">req = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> resp *<span class="keyword">float32</span> <span class="comment">//返回值</span></span><br><span class="line">err = client.Call(<span class="string">"MathUtil.CalculateCircleArea"</span>, req, &amp;resp)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(*resp)</span><br></pre></td></tr></table></figure></div>

上述的调用方法核心在于client.Call方法的调用，该方法有三个参数，第一个参数表示要调用的远端服务的方法名，第二个参数是调用时要传入的参数，第三个参数是调用要接收的返回值。
上述的Call方法调用实现的方式是同步的调用，除此之外，还有一种异步的方式可以实现调用。异步调用代码实现如下：

<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> respSync *<span class="keyword">float32</span></span><br><span class="line"><span class="comment">//异步的调用方式</span></span><br><span class="line">syncCall := client.Go(<span class="string">"MathUtil.CalculateCircleArea"</span>, req, &amp;respSync, <span class="literal">nil</span>)</span><br><span class="line">replayDone := &lt;-syncCall.Done</span><br><span class="line">fmt.Println(replayDone)</span><br><span class="line">fmt.Println(*respSync)</span><br></pre></td></tr></table></figure></div></code></pre></li>
</ul>
<h4 id="2-2-4、多参数的请求调用参数传递"><a href="#2-2-4、多参数的请求调用参数传递" class="headerlink" title="2.2.4、多参数的请求调用参数传递"></a>2.2.4、多参数的请求调用参数传递</h4><p>上述内容演示了单个参数下的 RPC 调用，对于多参数下的请求该如何实现。我们通过另外一个案例进行演示。</p>
<p>假设现在需要实现另外一个需求：通过 RPC 调用实现计算两个数字相加功能并返回计算结果。此时，就需要传递两个参数，具体实现如下：</p>
<p>将参数定义在一个新的结构体中，存放在 param 包中：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AddParma <span class="keyword">struct</span> &#123;</span><br><span class="line">	Args1 <span class="keyword">float32</span> <span class="comment">//第一个参数</span></span><br><span class="line">	Args2 <span class="keyword">float32</span> <span class="comment">//第二个参数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在 server.go 文件中，实现两数相加的功能，并实现服务注册的逻辑：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mu *MathUtil)</span> <span class="title">Add</span><span class="params">(param param.AddParma, resp *<span class="keyword">float32</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	*resp = param.Args1 + param.Args2 <span class="comment">//实现两数相加的功能</span></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">mathUtil := <span class="built_in">new</span>(MathUtil)</span><br><span class="line"></span><br><span class="line">	err := rpc.RegisterName(<span class="string">"MathUtil"</span>, mathUtil)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8082"</span>)</span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure></div>

<p>在本案例中，我们通过新的注册方法 rpc.RegisterName 实现了服务的注册和调用。</p>
<p>至此，我们已经完成了 net/rpc 包的最基础的使用。</p>
<h2 id="三、RPC-与-Protobuf-结合使用"><a href="#三、RPC-与-Protobuf-结合使用" class="headerlink" title="三、RPC 与 Protobuf 结合使用"></a>三、RPC 与 Protobuf 结合使用</h2><p>上节课我们使用 Golang 提供的核心 net/rpc 库实现了 RPC 调用编程。本节课继续来看一下 RPC 和之前所学的 Protobuf 在编程中的结合实现。</p>
<p>需求：假设在一个系统中，有订单模块（Order），其他模块想要实现 RPC 的远程工程调用，根据订单 ID 和时间戳可以获取订单信息。如果获取成功就返回相应的订单信息；如果查询不到返回失败信息。现在，我们来进行需求的编程实现。</p>
<h3 id="3-1、传输数据格式定义"><a href="#3-1、传输数据格式定义" class="headerlink" title="3.1、传输数据格式定义"></a>3.1、传输数据格式定义</h3><p>在《Go 语言微服务理论实践课程》中，学习过关于 Protobuf 的相关知识。可以利用 Protobuf 相关规则定义相应的数据格式,文件扩展名是.proto。</p>
<ul>
<li><p><strong>数据定义</strong><br>根据需求，定义 message.proto 文件，详细定义如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package message;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;订单请求参数</span><br><span class="line">message OrderRequest &#123;</span><br><span class="line">    string orderId &#x3D; 1;</span><br><span class="line">    int64 timeStamp &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;订单信息</span><br><span class="line">message OrderInfo &#123;</span><br><span class="line">    string OrderId &#x3D; 1;</span><br><span class="line">    string OrderName &#x3D; 2;</span><br><span class="line">    string OrderStatus &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

在上述文件中，定义了客户端发起RPC调用时的请求数据结构OrderRequest和服务端查询后返回的数据结构OrderInfo。数据定义采用proto3语法实现，整个数据定义被定义在message包下。</code></pre></li>
<li><p><strong>编译 proto 文件</strong><br>通过 proto 编译命令对.proto 文件进行编译，自动生成对应结构体的 Go 语言文件。编译命令如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc ./message.proto --go_out=./</span><br></pre></td></tr></table></figure></div></code></pre><p>执行上述命令是在 message 包下。编译命令结束后，会在 message 包下生成 message.pb.go 文件，其中自动生成了 OrderRequest 和 OrderInfo 在 Go 语言中结构体的定义和相关的方法。</p>
</li>
</ul>
<h3 id="3-2、Protobuf-格式数据与-RPC-结合"><a href="#3-2、Protobuf-格式数据与-RPC-结合" class="headerlink" title="3.2、Protobuf 格式数据与 RPC 结合"></a>3.2、Protobuf 格式数据与 RPC 结合</h3><ul>
<li><p><strong>服务的定义</strong><br>进行 RPC 远程过程调用，实现调用远程服务器的方法，首先要有服务。在本案例中，定义提供订单查询功能的服务，取名为 OrderService，同时提供订单信息查询方法供远程调用。详细的服务和方法定义如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//订单服务</span></span><br><span class="line"><span class="keyword">type</span> OrderService <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(os *OrderService)</span> <span class="title">GetOrderInfo</span><span class="params">(request message.OrderRequest, response *message.OrderInfo)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="comment">//201907310003</span></span><br><span class="line">	orderMap := <span class="keyword">map</span>[<span class="keyword">string</span>]message.OrderInfo&#123;</span><br><span class="line">		<span class="string">"201907300001"</span>: message.OrderInfo&#123;OrderId: <span class="string">"201907300001"</span>, OrderName: <span class="string">"衣服"</span>, OrderStatus: <span class="string">"已付款"</span>&#125;,</span><br><span class="line">		<span class="string">"201907310001"</span>: message.OrderInfo&#123;OrderId: <span class="string">"201907310001"</span>, OrderName: <span class="string">"零食"</span>, OrderStatus: <span class="string">"已付款"</span>&#125;,</span><br><span class="line">		<span class="string">"201907310002"</span>: message.OrderInfo&#123;OrderId: <span class="string">"201907310002"</span>, OrderName: <span class="string">"食品"</span>, OrderStatus: <span class="string">"未付款"</span>&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">   current := time.Now().Unix()</span><br><span class="line">   <span class="keyword">if</span> (request.TimeStamp &gt; current) &#123;</span><br><span class="line">	  *response = message.OrderInfo&#123;OrderId: <span class="string">"0"</span>, OrderName: <span class="string">""</span>, OrderStatus: <span class="string">"订单信息异常"</span>&#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  result := orderMap[request.OrderId]<span class="comment">//201907310003</span></span><br><span class="line">	  <span class="keyword">if</span> result.OrderId != <span class="string">""</span> &#123;</span><br><span class="line">		 *response = orderMap[request.OrderId]</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		 <span class="keyword">return</span> errors.New(<span class="string">"server error"</span>)</span><br><span class="line">	  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></code></pre><p>在服务的方法定义中，使用 orderMap 模拟初始订单数据库，方便案例查询展示。GetOrderInfo 方法有两个参数，第一个是 message.OrderRequest，作为调用者传递的参数，第二个是 message.OrderInfo，作为调用返回的参数，通过此处的两个参数，将上文通过.proto 定义并自动生成的 Go 语言结构体数据结合起来。</p>
</li>
<li><p><strong>服务的注册和处理</strong><br>服务定义好以后，需要将服务注册到 RPC 框架，并开启 http 请求监听处理。这部分代码与之前的 RPC 服务端实现逻辑一致，具体实现如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	orderService := <span class="built_in">new</span>(OrderService)</span><br><span class="line"></span><br><span class="line">	rpc.Register(orderService)</span><br><span class="line"></span><br><span class="line">	rpc.HandleHTTP()</span><br><span class="line"></span><br><span class="line">	listen, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8081"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line">	http.Serve(listen, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></code></pre></li>
<li><p><strong>RPC 客户端调用实现</strong><br>在客户端，除了客户端正常访问远程服务器的逻辑外，还需要准备客户端需要传递的请求数据 message.OrderInfo。具体实现如下：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">client, err := rpc.DialHTTP(<span class="string">"tcp"</span>, <span class="string">"localhost:8081"</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	timeStamp := time.Now().Unix()</span><br><span class="line">	request := message.OrderRequest&#123;OrderId: <span class="string">"201907310001"</span>, TimeStamp: timeStamp&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> response *message.OrderInfo</span><br><span class="line">	err = client.Call(<span class="string">"OrderService.GetOrderInfo"</span>, request, &amp;response)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(err.Error())</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fmt.Println(*response)</span><br></pre></td></tr></table></figure></div></code></pre></li>
</ul>
<h3 id="3-3、运行结果"><a href="#3-3、运行结果" class="headerlink" title="3.3、运行结果"></a>3.3、运行结果</h3><p>分别依次运行 server.go 和 client.go 程序。运行结果如下：<br><a href="/img/weifuwu/WX20190802-085939@2x.png" data-fancybox="group" data-caption="运行结果" class="fancybox"><img alt="运行结果" title="运行结果" data-src="/img/weifuwu/WX20190802-085939@2x.png" class="lazyload"></a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wangguangatap</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wangguangatap.github.io/2020/01/27/RPC%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/">https://wangguangatap.github.io/2020/01/27/RPC%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://wangguangatap.github.io/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangguangatap.github.io">星脉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang    </a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务    </a></div><div class="post_share"><div class="social-share" data-image="/img/weifuwu/weifuwu.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86(%E4%B8%8B)/"><img class="prev_cover lazyload" data-src="/img/weifuwu/weifuwu.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>微服务：(三)微服务管理(下)</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/27/gRPC%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8%E6%9C%BA%E5%88%B6%E4%BB%8B%E7%BB%8D/"><img class="next_cover lazyload" data-src="/img/weifuwu/weifuwu.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>微服务：(五)gRPC远程调用机制介绍</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/27/gRPC远程调用机制介绍/" title="微服务：(五)gRPC远程调用机制介绍"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(五)gRPC远程调用机制介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/RESTful标准设计/" title="微服务：(九)RESTful标准设计"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(九)RESTful标准设计</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务简介及特性介绍/" title="微服务：(一)微服务简介及特性介绍"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(一)微服务简介及特性介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/Protobuf介绍/" title="微服务：(二)Protobuf介绍"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(二)Protobuf介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务管理(上)/" title="微服务：(二)微服务管理(上)"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(二)微服务管理(上)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务管理(下)/" title="微服务：(三)微服务管理(下)"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(三)微服务管理(下)</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By wangguangatap</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>