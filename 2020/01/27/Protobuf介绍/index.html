<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5"><title>微服务：(二)Protobuf介绍 | 星脉</title><meta name="description" content="微服务：(二)Protobuf介绍"><meta name="keywords" content="Golang,微服务"><meta name="author" content="wangguangatap"><meta name="copyright" content="wangguangatap"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin><link rel="preconnect" href="//busuanzi.ibruce.info"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="微服务：(二)Protobuf介绍"><meta name="twitter:description" content="微服务：(二)Protobuf介绍"><meta name="twitter:image" content="https://wangguangatap.github.io/img/weifuwu/weifuwu.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="微服务：(二)Protobuf介绍"><meta property="og:url" content="https://wangguangatap.github.io/2020/01/27/Protobuf%E4%BB%8B%E7%BB%8D/"><meta property="og:site_name" content="星脉"><meta property="og:description" content="微服务：(二)Protobuf介绍"><meta property="og:image" content="https://wangguangatap.github.io/img/weifuwu/weifuwu.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>const autoChangeMode = 'false'
var t = Cookies.get("theme");
if (autoChangeMode == '1'){
const isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
const isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
const isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

if (t === undefined){
  if (isLightMode) activateLightMode()
  else if (isDarkMode) activateDarkMode()
  else if (isNotSpecified || hasNoSupport){
    console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
    now = new Date();
    hour = now.getHours();
    isNight = hour < 6 || hour >= 18
    isNight ? activateDarkMode() : activateLightMode()
}
} else if (t == 'light') activateLightMode()
else activateDarkMode()


} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="https://wangguangatap.github.io/2020/01/27/Protobuf%E4%BB%8B%E7%BB%8D/"><link rel="prev" title="微服务：(一)微服务简介及特性介绍" href="https://wangguangatap.github.io/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/"><link rel="next" title="微服务：(二)微服务管理(上)" href="https://wangguangatap.github.io/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86(%E4%B8%8A)/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: 'Snackbar.bookmark.title',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  isHome: false,
  isPost: true
  
}</script><meta name="generator" content="Hexo 4.2.0"></head><body><header> <div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">星脉</a></span><span class="toggle-menu pull_right close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></span></div></header><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">8</div></a></div></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></div></div></div><div id="mobile-sidebar-toc"><div class="toc_mobile_headline">目录</div><div class="sidebar-toc__content"><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-1"><a class="toc_mobile_items-link" href="#Protocol-buffer"><span class="toc_mobile_items-text">Protocol buffer</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#一、Protobuf-简介"><span class="toc_mobile_items-text">一、Protobuf 简介</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-1、RPC-通信"><span class="toc_mobile_items-text">1.1、RPC 通信</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-2、RPC-实现步骤"><span class="toc_mobile_items-text">1.2、RPC 实现步骤</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-3、Protobuf-简介"><span class="toc_mobile_items-text">1.3、Protobuf 简介</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-4、Protobuf-应用场景"><span class="toc_mobile_items-text">1.4、Protobuf 应用场景</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-5、Protobuf-优点"><span class="toc_mobile_items-text">1.5、Protobuf 优点</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#1-6、Protobuf-缺点"><span class="toc_mobile_items-text">1.6、Protobuf 缺点</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-2"><a class="toc_mobile_items-link" href="#二、Protobuf-在-Go-语言中的编程实现"><span class="toc_mobile_items-text">二、Protobuf 在 Go 语言中的编程实现</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-1、环境准备"><span class="toc_mobile_items-text">2.1、环境准备</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-2、安装"><span class="toc_mobile_items-text">2.2、安装</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-3、Protobuf-协议语法"><span class="toc_mobile_items-text">2.3、Protobuf 协议语法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#2-4、使用-Protobuf-的步骤"><span class="toc_mobile_items-text">2.4、使用 Protobuf 的步骤</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true">     </i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Protocol-buffer"><span class="toc-text">Protocol buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#一、Protobuf-简介"><span class="toc-text">一、Protobuf 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1、RPC-通信"><span class="toc-text">1.1、RPC 通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2、RPC-实现步骤"><span class="toc-text">1.2、RPC 实现步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3、Protobuf-简介"><span class="toc-text">1.3、Protobuf 简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4、Protobuf-应用场景"><span class="toc-text">1.4、Protobuf 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5、Protobuf-优点"><span class="toc-text">1.5、Protobuf 优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-6、Protobuf-缺点"><span class="toc-text">1.6、Protobuf 缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二、Protobuf-在-Go-语言中的编程实现"><span class="toc-text">二、Protobuf 在 Go 语言中的编程实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1、环境准备"><span class="toc-text">2.1、环境准备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2、安装"><span class="toc-text">2.2、安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3、Protobuf-协议语法"><span class="toc-text">2.3、Protobuf 协议语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4、使用-Protobuf-的步骤"><span class="toc-text">2.4、使用 Protobuf 的步骤</span></a></li></ol></li></ol></li></ol></div></div></div><main id="content-outer"><div id="top-container" style="background-image: url(/img/weifuwu/weifuwu.jpeg)"><div id="post-info"><div id="post-title"><div class="posttitle">微服务：(二)Protobuf介绍</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 发表于 2020-01-27<span class="post-meta__separator">|</span><i class="fa fa-history fa-fw" aria-hidden="true"></i> 更新于 2020-06-01</time><span class="post-meta__separator">|</span><span><i class="fa fa-inbox post-meta__icon fa-fw" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a></span><div class="post-meta-wordcount"><div class="post-meta-pv-cv"><span><i class="fa fa-eye post-meta__icon fa-fw" aria-hidden="true"> </i>阅读量:</span><span id="busuanzi_value_page_pv"></span></div></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h1 id="Protocol-buffer"><a href="#Protocol-buffer" class="headerlink" title="Protocol buffer"></a>Protocol buffer</h1><h2 id="一、Protobuf-简介"><a href="#一、Protobuf-简介" class="headerlink" title="一、Protobuf 简介"></a>一、Protobuf 简介</h2><h3 id="1-1、RPC-通信"><a href="#1-1、RPC-通信" class="headerlink" title="1.1、RPC 通信"></a>1.1、RPC 通信</h3><p>对于单独部署，独立运行的微服务实例而言，在业务需要时，需要与其他服务进行通信，这种通信方式是进程之间的通讯方式（inter-process communication，简称 IPC）。</p>
<p>前文已经描述过，IPC 有两种实现方式，分别为：<strong>同步过程调用、异步消息调用</strong>。在同步过程调用的具体实现中，有一种实现方式为 RPC 通信方式，远程过程调用（英语：Remote Procedure Call，缩写为 RPC）。</p>
<p>远程过程调用（英语：Remote Procedure Call，缩写为 RPC）是一个计算机通信协议。该协议允许运行于一台计算机的程序调用另一台计算机的子程序，而程序员无需额外地为这个交互作用编程。如果涉及的软件采用面向对象编程，那么远程过程调用亦可称作远程调用或远程方法调用，例：Java RMI。<strong>简单地说就是能使应用像调用本地方法一样的调用远程的过程或服务。</strong>很显然，这是一种 client-server 的交互形式，调用者(caller)是 client,执行者(executor)是 server。典型的实现方式就是 request–response 通讯机制。</p>
<h3 id="1-2、RPC-实现步骤"><a href="#1-2、RPC-实现步骤" class="headerlink" title="1.2、RPC 实现步骤"></a>1.2、RPC 实现步骤</h3><p>一个正常的 RPC 过程可以分为一下几个步骤：</p>
<ul>
<li><p>1、client 调用 client stub，这是一次本地过程调用。</p>
</li>
<li><p>2、client stub 将参数打包成一个消息，然后发送这个消息。打包过程也叫做 marshalling。</p>
</li>
<li><p>3、client 所在的系统将消息发送给 server。</p>
</li>
<li><p>4、server 的的系统将收到的包传给 server stub。</p>
</li>
<li><p>5、server stub 解包得到参数。 解包也被称作 unmarshalling。</p>
</li>
<li><p>6、server stub 调用服务过程。返回结果按照相反的步骤传给 client。</p>
</li>
</ul>
<p>在上述的步骤实现远程接口调用时，所需要执行的函数是存在于远程机器中，即函数是在另外一个进程中执行的。因此，就带来了几个新问题：</p>
<ul>
<li><p><strong>1、Call ID 映射。</strong>远端进程中间可以包含定义的多个函数，本地客户端该如何告知远端进程程序调用特定的某个函数呢？因此，在 RPC 调用过程中，所有的函数都需要有一个自己的 ID。开发者在客户端（调用端）和服务端（被调用端）分别维护一个{函数&lt;–&gt;Call ID}的对应表。两者的表不一定完全相同，但是相同的函数对应的 Call ID 必须相同。当客户端需要进行远程调用时，调用者通过映射表查询想要调用的函数的名称，找到对应的 Call ID，然后传递给服务端，服务端也通过查表，来确定客户端所需要调用的函数，然后执行相应函数的代码。</p>
</li>
<li><p><strong>2、序列化与反序列化。</strong>客户端如何把参数传递给远程调用的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用 C++，客户端用 Java 或者 Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
</li>
<li><p><strong>3、网络传输。</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把 Call ID 和序列化后的参数字节流传递给服务端，然后在把序列化后的调用结果传回给客户端，完成这种数据传递功能的被成为传输层。大部分的网络传输成都使用 TCP 协议，属于长连接。</p>
</li>
</ul>
<p>在上述步骤实现中，可以看到其中有对传递的数据进行序列化和反序列化的操作，这就是我们本节内容开始要学习的内容：<strong>Protobuf</strong>。</p>
<h3 id="1-3、Protobuf-简介"><a href="#1-3、Protobuf-简介" class="headerlink" title="1.3、Protobuf 简介"></a>1.3、Protobuf 简介</h3><p>Google Protocol Buffer( 简称 Protobuf)是 Google 公司内部的混合语言数据标准，他们主要用于 RPC 系统和持续数据存储系统。</p>
<h3 id="1-4、Protobuf-应用场景"><a href="#1-4、Protobuf-应用场景" class="headerlink" title="1.4、Protobuf 应用场景"></a>1.4、Protobuf 应用场景</h3><p>Protocol Buffers 是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或 RPC 数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。</p>
<p>简单来说，Protobuf 的功能类似于 XML，即负责把某种数据结构的信息，以某种格式保存起来。主要用于数据存储、传输协议等使用场景。</p>
<p>为什么已经有了 XLM，JSON 等已经很普遍的数据传输方式，还要设计出 Protobuf 这样一种新的数据协议呢？</p>
<h3 id="1-5、Protobuf-优点"><a href="#1-5、Protobuf-优点" class="headerlink" title="1.5、Protobuf 优点"></a>1.5、Protobuf 优点</h3><ul>
<li><p><strong>性能好/效率高</strong></p>
<ul>
<li>时间维度：采用 XML 格式对数据进行序列化时，时间消耗上性能尚可；对于使用 XML 格式对数据进行反序列化时的时间花费上，耗时长，性能差。</li>
<li>空间维度：XML 格式为了保持较好的可读性，引入了一些冗余的文本信息。所以在使用 XML 格式进行存储数据时，也会消耗空间。</li>
</ul>
<p>整体而言，Protobuf 以高效的二进制方式存储，比 XML 小 3 到 10 倍，快 20 到 100 倍。</p>
</li>
<li><p><strong>代码生成机制</strong></p>
<ul>
<li><p><strong>代码生成机制的含义</strong></p>
<p>在 Go 语言中，可以通过定义结构体封装描述一个对象，并构造一个新的结构体对象。比如定义 Person 结构体，并存放于 Person.go 文件：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Person <span class="keyword">struct</span>&#123;</span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">    Sex <span class="keyword">int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在分布式系统中，因为程序代码时分开部署，比如分别为 A、B。A 系统在调用 B 系统时，无法直接采用代码的方式进行调用，因为 A 系统中不存在 B 系统中的代码。因此，A 系统只负责将调用和通信的数据以二进制数据包的形式传递给 B 系统，由 B 系统根据获取到的数据包，自己构建出对应的数据对象，生成数据对象定义代码文件。这种利用编译器，根据数据文件自动生成结构体定义和相关方法的文件的机制被称作代码生成机制。</p>
</li>
<li><p><strong>代码生成机制的优点</strong><br>首先，代码生成机制能够极大解放开发者编写数据协议解析过程的时间，提高工作效率；其次，易于开发者维护和迭代，当需求发生变更时，开发者只需要修改对应的数据传输文件内容即可完成所有的修改。</p>
</li>
</ul>
</li>
<li><p><strong>支持“向后兼容”和“向前兼容”</strong></p>
<ul>
<li><p><strong>向后兼容：</strong>在软件开发迭代和升级过程中，”后”可以理解为新版本，越新的版本越靠后；而“前”意味着早起的版本或者先前的版本。向“后”兼容即是说当系统升级迭代以后，仍然可以处理老版本的数据业务逻辑。</p>
</li>
<li><p><strong>向前兼容：</strong>向前兼容即是系统代码未升级，但是接受到了新的数据，此时老版本生成的系统代码可以处理接收到的新类型的数据。</p>
</li>
</ul>
<p>支持前后兼容是非常重要的一个特点，在庞大的系统开发中，往往不可能统一完成所有模块的升级，为了保证系统功能正常不受影响，应最大限度保证通讯协议的向前兼容和向后兼容。</p>
</li>
<li><p><strong>支持多种编程语言</strong><br>Protobuf 不仅仅 Google 开源的一个数据协议，还有很多种语言的开源项目实现。在 Google 官方发布的 Protobuf 的源代码中包含了 C++、Java、Python 三种语言。本系列课程中，我们学习如何实现 Golang 语言中的功能实现。</p>
</li>
</ul>
<h3 id="1-6、Protobuf-缺点"><a href="#1-6、Protobuf-缺点" class="headerlink" title="1.6、Protobuf 缺点"></a>1.6、Protobuf 缺点</h3><ul>
<li><p><strong>可读性较差</strong><br>为了提高性能，Protobuf 采用了二进制格式进行编码。二进制格式编码对于开发者来说，是没办法阅读的。在进行程序调试时，比较困难。</p>
</li>
<li><p><strong>缺乏自描述</strong><br>诸如 XML 语言是一种自描述的标记语言，即字段标记的同时就表达了内容对应的含义。而 Protobuf 协议不是自描述的，Protobuf 是通过二进制格式进行数据传输，开发者面对二进制格式的 Protobuf，没有办法知道所对应的真实的数据结构，因此在使用 Protobuf 协议传输时，必须配备对应的 proto 配置文件。</p>
</li>
</ul>
<h2 id="二、Protobuf-在-Go-语言中的编程实现"><a href="#二、Protobuf-在-Go-语言中的编程实现" class="headerlink" title="二、Protobuf 在 Go 语言中的编程实现"></a>二、Protobuf 在 Go 语言中的编程实现</h2><p>Go 语言中有对应的实现 Protobuf 协议的库，Github 地址：<a href="https://github.com/golang/protobuf" target="_blank" rel="noopener">https://github.com/golang/protobuf</a></p>
<h3 id="2-1、环境准备"><a href="#2-1、环境准备" class="headerlink" title="2.1、环境准备"></a>2.1、环境准备</h3><p>使用 Go 语言的 Protobuf 库之前，需要相应的环境准备：</p>
<ul>
<li><p><strong>1、安装 protobuf 编译器。</strong><br>可以在如下地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">https://github.com/protocolbuffers/protobuf/releases</a>选择适合自己系统的 Proto 编译器程序进行下载并解压，如图：<br><a href="/img/weifuwu/WX20190605-095735@2x.png" data-fancybox="group" data-caption="Protoc编译器" class="fancybox"><img alt="Protoc编译器" title="Protoc编译器" data-src="/img/weifuwu/WX20190605-095735@2x.png" class="lazyload"></a></p>
</li>
<li><p><strong>2、配置环境变量</strong><br>protoc 编译器正常运行需要进行环境变量配置，将 protocke 执行文件所在目录添加到当前系统的环境变量中。windows 系统下可以直接在 Path 目录中进行添加；macOS 系统下可以将 protoc 可执行文件拷贝至<strong>/usr/local/include</strong>目录下。具体的对应的系统的环境变量配置可以阅读解压后与 bin 目录同级的 readme.txt 的文件内容。</p>
</li>
</ul>
<h3 id="2-2、安装"><a href="#2-2、安装" class="headerlink" title="2.2、安装"></a>2.2、安装</h3><p>通过如下命令安装 protoc-gen-go 库：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com&#x2F;golang&#x2F;protobuf&#x2F;protoc-gen-go</span><br></pre></td></tr></table></figure></div>

<p><a href="/img/weifuwu/protobuf.png" data-fancybox="group" data-caption="protoc安装后" class="fancybox"><img alt="protoc安装后" title="protoc安装后" data-src="/img/weifuwu/protobuf.png" class="lazyload"></a></p>
<p>安装完成以后，protoc-gen-go*可执行文件在本地环境 GOPATH/bin 目录下，如下图所示：<br><a href="/img/weifuwu/WX20190604-155039@2x.png" data-fancybox="group" data-caption="protoc-gen-go执行文件" class="fancybox"><img alt="protoc-gen-go执行文件" title="protoc-gen-go执行文件" data-src="/img/weifuwu/WX20190604-155039@2x.png" class="lazyload"></a></p>
<h3 id="2-3、Protobuf-协议语法"><a href="#2-3、Protobuf-协议语法" class="headerlink" title="2.3、Protobuf 协议语法"></a>2.3、Protobuf 协议语法</h3><ul>
<li><p><strong>Protobuf 协议的格式</strong><br>Protobuf 协议规定：使用该协议进行数据序列化和反序列化操作时，首先定义传输数据的格式，并命名为以<strong>“.proto”</strong>为扩展名的消息定义文件。</p>
</li>
<li><p><strong>message 定义一个消息</strong><br>先来看一个非常简单的例子。假设想定义一个“订单”的消息格式，每一个“订单”都含有一个订单号 ID、订单金额 Num、订单时间 TimeStamp 字段。可以采用如下的方式来定义消息类型的.proto 文件：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">message Order&#123;</span><br><span class="line">    required string order_id &#x3D; 1;</span><br><span class="line">    required int64 num &#x3D; 2;</span><br><span class="line">    optional int32 timestamp &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></code></pre><p>Order 消息格式有 3 个字段，在消息中承载的数据分别对应每一个字段。其中每个字段都有一个名字和一种类型。<br>_ <strong>指定字段类型：</strong>在 proto 协议中，字段的类型包括字符串（string)、整形（int32、int64…）、枚举（enum）等数据类型<br>_ <strong>分配标识符：</strong>在消息字段中，每个字段都有唯一的一个标识符。最小的标识号可以从 1 开始，最大到 536870911。不可以使用其中的[19000－19999]的标识号， Protobuf 协议实现中对这些进行了预留。如果非要在.proto 文件中使用这些预留标识号，编译时就会报警。<br>_ <strong>指定字段规则：</strong>字段的修饰符包含三种类型，分别是：<br>_ <strong>required：</strong>一个格式良好的消息一定要含有 1 个这种字段。表示该值是必须要设置的；<br>_ <strong>optional：</strong>消息格式中该字段可以有 0 个或 1 个值（不超过 1 个）。<br>_ <strong>repeated：</strong>在一个格式良好的消息中，这种字段可以重复任意多次（包括 0 次）。重复的值的顺序会被保留。表示该值可以重复，相当于 Go 中的 slice。</p>
<p><strong>【注意：】使用 required 弊多于利；在实际开发中更应该使用 optional 和 repeated 而不是 required。</strong> * 添加更多消息类型<br>在同一个.proto 文件中，可以定义多个消息类型。多个消息类型分开定义即可。</p>
</li>
</ul>
<h3 id="2-4、使用-Protobuf-的步骤"><a href="#2-4、使用-Protobuf-的步骤" class="headerlink" title="2.4、使用 Protobuf 的步骤"></a>2.4、使用 Protobuf 的步骤</h3><ul>
<li><p>1、创建扩展名为<strong>.proto</strong>的文件，并编写代码。比如创建 person.proto 文件，内容如下：</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto2&quot;;</span><br><span class="line">package example;</span><br><span class="line"></span><br><span class="line">message Person &#123;</span><br><span class="line">    required string Name &#x3D; 1;</span><br><span class="line">    required int32 Age &#x3D; 2;</span><br><span class="line">    required string From &#x3D; 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>2、编译.proto 文件，生成 Go 语言文件。执行如下命令：</p>
<p><code>protoc --go_out = . test.proto</code><br>执行 protoc –go_out=. test.proto 生成对应的 person.pb.go 文件。并构建对应的 example 目录，存放生成的 person.pb.go 文件。<br><a href="http://7xtcwd.com1.z0.glb.clouddn.com/WX20190605-101438@2x.png" target="_blank" rel="noopener" data-fancybox="group" data-caption="Proto生成Go语言" class="fancybox"><img alt="Proto生成Go语言" title="Proto生成Go语言" data-src="http://7xtcwd.com1.z0.glb.clouddn.com/WX20190605-101438@2x.png" class="lazyload"></a></p>
</li>
<li><p>3、在程序中使用 Protobuf<br>在程序中有如下代码：</p>
<pre><code><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">go</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">package</span> main</span><br><span class="line">    <span class="keyword">import</span> (</span><br><span class="line">    	<span class="string">"fmt"</span></span><br><span class="line">    	<span class="string">"ProtocDemo/example"</span></span><br><span class="line">    	<span class="string">"github.com/golang/protobuf/proto"</span></span><br><span class="line">    	<span class="string">"os"</span></span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">fmt.Println(<span class="string">"Hello World. \n"</span>)</span><br><span class="line"></span><br><span class="line">    msg_test := &amp;example.Person&#123;</span><br><span class="line">    	Name: proto.String(<span class="string">"Davie"</span>),</span><br><span class="line">    	Age:  proto.Int(<span class="number">18</span>),</span><br><span class="line">    	From: proto.String(<span class="string">"China"</span>),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    msgDataEncoding, err := proto.Marshal(msg_test)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	<span class="built_in">panic</span>(err.Error())</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    msgEntity := example.Person&#123;&#125;</span><br><span class="line">    err = proto.Unmarshal(msgDataEncoding, &amp;msgEntity)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    	fmt.Println(err.Error())</span><br><span class="line">    	os.Exit(<span class="number">1</span>)</span><br><span class="line">    	<span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"姓名：%s\n\n"</span>, msgEntity.GetName())</span><br><span class="line">    fmt.Printf(<span class="string">"年龄：%d\n\n"</span>, msgEntity.GetAge())</span><br><span class="line">    fmt.Printf(<span class="string">"国籍：%s\n\n"</span>, msgEntity.GetFrom())</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></code></pre><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **3、执行程序**</span><br><span class="line">  ![运行程序](http:&#x2F;&#x2F;7xtcwd.com1.z0.glb.clouddn.com&#x2F;WX20190605-102000@2x.png)</span><br><span class="line"></span><br><span class="line">## 三、Protobuf 协议语法与原理实现</span><br><span class="line"></span><br><span class="line">### 3.1、Protobuf 协议语法</span><br><span class="line"></span><br><span class="line">- **message：**</span><br><span class="line">  Protobuf 中定义一个数据结构需要用到关键字 message，这一点和 Java 的 class，Go 语言中的 struct 类似。</span><br><span class="line"></span><br><span class="line">- **标识号：**</span><br><span class="line">  在消息的定义中，每个字段等号后面都有唯一的标识号，用于在反序列化过程中识别各个字段的，一旦开始使用就不能改变。标识号从整数 1 开始，依次递增，每次增加 1，标识号的范围为 1~2^29 - 1，其中[19000-19999]为 Protobuf 协议预留字段，开发者不建议使用该范围的标识号；一旦使用，在编译时 Protoc 编译器会报出警告。</span><br><span class="line"></span><br><span class="line">- **字段规则：**</span><br><span class="line">  字段规则有三种：</span><br><span class="line">  _ 1、required：该规则规定，消息体中该字段的值是必须要设置的。</span><br><span class="line">  _ 2、optional：消息体中该规则的字段的值可以存在，也可以为空，optional 的字段可以根据 defalut 设置默认值。 \* repeated：消息体中该规则字段可以存在多个（包括 0 个），该规则对应 java 的数组或者 go 语言的 slice。</span><br><span class="line">- **数据类型：**</span><br><span class="line">  常见的数据类型与 protoc 协议中的数据类型映射如下：</span><br><span class="line"></span><br><span class="line">      | \.proto类型 | Java类型    | C\+\+类型 | Go语言类型  | 备注                                       |</span><br><span class="line"></span><br><span class="line">  |-----------|-----------|---------|---------|------------------------------------------|</span><br><span class="line">  | double | double | double | float64 | |</span><br><span class="line">  | float | float | float | float32 | |</span><br><span class="line">  | int32 | int | int | int32 | 可变长编码方式。编码负数时不够高效，如果字段可能包含负数，可以使用 sint32 |</span><br><span class="line">  | int64 | long | int64 | int64 | 可变长编码方式。编码负数时不够高效，如果字段可能包含负数，使用 sint64。 |</span><br><span class="line">  | uint32 | int\[1\] | uint32 | uint32 | |</span><br><span class="line">  | uint64 | | uint64 | uint64 | |</span><br><span class="line">  | sint32 | int | int32 | int32 | 可变长编码方式，有符号的整形值。编码时比 int32 效率高。 |</span><br><span class="line">  | sint64 | long | int64 | int64 | 可变长编码方式，有符号的整形值，编码时比 int64 效率高。 |</span><br><span class="line">  | fixed32 | int\[1\] | uint32 | uint32 | 总是 4 个字节。如果所有数值均比（2^28\)大，该种编码方式比 uint32 高效。 |</span><br><span class="line">  | fixed64 | long\[1\] | uint64 | uint64 | 总是 8 个字节。如果所有数值均比（2^56\)大，此种编码方式比 uint64 高效。 |</span><br><span class="line">  | sfixed32 | int | uint32 | int32 | 总是 4 个字节。 |</span><br><span class="line">  | sfixed64 | long | uint64 | int64 | 总是 8 个字节。 |</span><br><span class="line">  | bool | boolean | bool | bool | |</span><br><span class="line">  | string | String | String | string | |</span><br><span class="line"></span><br><span class="line">- **枚举类型：**</span><br><span class="line">  proto 协议支持使用枚举类型，和正常的编程语言一样，枚举类型可以使用 enum 关键字定义在.proto 文件中：</span><br><span class="line">  &#96;go enum Age&#123; male&#x3D;1; female&#x3D;2; &#125;&#96;</span><br><span class="line">- **字段默认值：**</span><br><span class="line">  .proto 文件支持在进行 message 定义时设置字段的默认值，可以通过**default**进行设置，如下所示：</span><br></pre></td></tr></table></figure></div>
<p>message Address {</p>
<pre><code>required sint32 id = 1 [default = 1];
required string name = 2 [default = &apos;北京&apos;];
optional string pinyin = 3 [default = &apos;beijing&apos;];
required string address = 4;
required bool flag = 5 [default = true];</code></pre><p>  }</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- **导入：**</span><br><span class="line">  如果需要引用的 message 是写在别的.proto 文件中，可以通过 import &quot;xxx.proto&quot;来进行引入：</span><br><span class="line"></span><br><span class="line">* **嵌套：**</span><br><span class="line">  message 与 message 之间可以嵌套定义，比如如下形式：</span><br></pre></td></tr></table></figure></div>
<pre><code>syntax = &quot;proto2&quot;;
package example;
message Person {
    required string Name = 1;
    required int32 Age = 2;
    required string From = 3;
    optional Address Addr = 4;
    message Address {
        required sint32 id = 1;
        required string name = 2;
        optional string pinyin = 3;
        required string address = 4;
    }
}
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* **message 更新规则：**</span><br><span class="line">  message 定义以后如果需要进行修改，为了保证之前的序列化和反序列化能够兼容新的 message，message 的修改需要满足以下规则：</span><br><span class="line">  \_ 不可以修改已存在域中的标识号。</span><br><span class="line">  \_ 所有新增添的域必须是 optional 或者 repeated。</span><br><span class="line">  \_ 非 required 域可以被删除。但是这些被删除域的标识号不可以再次被使用。</span><br><span class="line">  \_ 非 required 域可以被转化，转化时可能发生扩展或者截断，此时标识号和名称都是不变的。</span><br><span class="line">  \_ sint32 和 sint64 是相互兼容的。</span><br><span class="line">  \_ fixed32 兼容 sfixed32。 fixed64 兼容 sfixed64。 \* optional 兼容 repeated。发送端发送 repeated 域，用户使用 optional 域读取，将会读取 repeated 域的最后一个元素。</span><br><span class="line"></span><br><span class="line">Protobuf 序列化后所生成的二进制消息非常紧凑，这得益于 Protobuf 采用的非常巧妙的 Encoding 方法。接下来看一看 Protobuf 协议是如何实现高效编码的。</span><br><span class="line"></span><br><span class="line">### 3.2、Protobuf 序列化原理</span><br><span class="line"></span><br><span class="line">之前已经做过描述，Protobuf 的 message 中有很多字段，每个字段的格式为：**修饰符 字段类型 字段名 &#x3D; 域号; **</span><br><span class="line"></span><br><span class="line">#### 3.2.1、Varint</span><br><span class="line"></span><br><span class="line">Varint 是一种紧凑的表示数字的方法。它用一个或多个字节来表示一个数字，值越小的数字使用越少的字节数。这能减少用来表示数字的字节数。</span><br><span class="line"></span><br><span class="line">Varint 中的每个 byte 的最高位 bit 有特殊的含义，如果该位为 1，表示后续的 byte 也是该数字的一部分，如果该位为 0，则结束。其他的 7 个 bit 都用来表示数字。因此小于 128 的数字都可以用一个 byte 表示。大于 128 的数字，比如 300，会用两个字节来表示：1010 1100 0000 0010。下图演示了 Google Protocol Buffer 如何解析两个 bytes。注意到最终计算前将两个 byte 的位置相互交换过一次，这是因为 Google Protocol Buffer 字节序采用 little-endian 的方式。</span><br><span class="line">![小端位序排列的Varint编码](&#x2F;img&#x2F;weifuwu&#x2F;121732zuyzkxzxjkwwjkx5.jpg)</span><br><span class="line"></span><br><span class="line">在序列化时，Protobuf 按照 TLV 的格式序列化每一个字段，T 即 Tag，也叫 Key；V 是该字段对应的值 value；L 是 Value 的长度，如果一个字段是整形，这个 L 部分会省略。</span><br><span class="line"></span><br><span class="line">序列化后的 Value 是按原样保存到字符串或者文件中，Key 按照一定的转换条件保存起来，序列化后的结果就是 KeyValueKeyValue…依次类推的样式，示意图如下所示：</span><br><span class="line">![序列化格式](&#x2F;img&#x2F;weifuwu&#x2F;121758l5mln3mnvpvc4mzw.jpg)</span><br><span class="line"></span><br><span class="line">采用这种 Key-Pair 结构无需使用分隔符来分割不同的 Field。对于可选的 Field，如果消息中不存在该 field，那么在最终的 Message Buffer 中就没有该 field，这些特性都有助于节约消息本身的大小。比如，我们有消息 order1:</span><br></pre></td></tr></table></figure></div></code></pre><p>Order.id = 10;<br>Order.desc = “bill”;</p>
<div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">则最终的 Message Buffer 中有两个 Key-Value 对，一个对应消息中的 id；另一个对应 desc。Key 用来标识具体的 field，在解包的时候，Protocol Buffer 根据 Key 就可以知道相应的 Value 应该对应于消息中的哪一个 field。</span><br><span class="line"></span><br><span class="line">Key 的定义如下：</span><br></pre></td></tr></table></figure></div>
<p>(field_number &lt;&lt; 3) | wire_type</p>
<pre><code></code></pre></li>
</ul>
<p>可以看到 Key 由两部分组成。第一部分是 field_number，比如消息 lm.helloworld 中 field id 的 field_number 为 1。第二部分为 wire_type。表示 Value 的传输类型。而 wire_type 有以下几种类型：</p>
<p><a href="/img/weifuwu/WX20190606-174515@2x.png" data-fancybox="group" data-caption="wire_type类型" class="fancybox"><img alt="wire_type类型" title="wire_type类型" data-src="/img/weifuwu/WX20190606-174515@2x.png" class="lazyload"></a></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">wangguangatap</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://wangguangatap.github.io/2020/01/27/Protobuf%E4%BB%8B%E7%BB%8D/">https://wangguangatap.github.io/2020/01/27/Protobuf%E4%BB%8B%E7%BB%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://wangguangatap.github.io/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://wangguangatap.github.io">星脉</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Golang/">Golang    </a><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务    </a></div><div class="post_share"><div class="social-share" data-image="/img/weifuwu/weifuwu.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/wechat.jpg" alt="微信"><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%89%B9%E6%80%A7%E4%BB%8B%E7%BB%8D/"><img class="prev_cover lazyload" data-src="/img/weifuwu/weifuwu.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>微服务：(一)微服务简介及特性介绍</span></div></a></div><div class="next-post pull_right"><a href="/2020/01/27/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%A1%E7%90%86(%E4%B8%8A)/"><img class="next_cover lazyload" data-src="/img/weifuwu/weifuwu.jpeg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>微服务：(二)微服务管理(上)</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/01/27/wei/" title="微服务"><img class="relatedPosts_cover lazyload"data-src="/img/golang/golang.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务简介及特性介绍/" title="微服务：(一)微服务简介及特性介绍"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(一)微服务简介及特性介绍</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务管理(上)/" title="微服务：(二)微服务管理(上)"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(二)微服务管理(上)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/微服务管理(下)/" title="微服务：(三)微服务管理(下)"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(三)微服务管理(下)</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/RPC远程过程调用/" title="微服务：(四)RPC远程过程调用"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(四)RPC远程过程调用</div></div></a></div><div class="relatedPosts_item"><a href="/2020/01/27/gRPC远程调用机制介绍/" title="微服务：(五)gRPC远程调用机制介绍"><img class="relatedPosts_cover lazyload"data-src="/img/weifuwu/weifuwu.jpeg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-01-27</div><div class="relatedPosts_title">微服务：(五)gRPC远程调用机制介绍</div></div></a></div></div><div class="clear_both"></div></div></div></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2020 By wangguangatap</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="ribbon_piao" mobile="false" src="https://cdn.jsdelivr.net/gh/jerryc127/butterfly_cdn@2.1.0/js/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script></body></html>